هذا مشروع Fultter كامل للدردشة والمطابقة والمواعدة والتوافق من فضل قم بالتعديل الكامل وأصلاح جميع الأخطاء وأكمال جميع الوظائف وأكمال التحسيانات وأكمال جميع المهام وأكمال جميع المهام وجميع الدوال وجميع الأحداث وجميع التركيبات وجميع الوظائف والتشغيل الكامل والخوارزميات والأكواد الحقيقية الفعلية والأجراءات والتغيرات مع إنشاء قاعدة بيانات كاملة بأستخدام Supabase ومن فضلك قم بأعادة البناء كامل بعد أضافة كل التعديلات والتوافقات وأكمال جميع التنفيذات الحقيقية والفعلية :
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:audioplayers/audioplayers.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:image_picker/image_picker.dart';
import 'package:lottie/lottie.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import 'package:go_router/go_router.dart';

import 'main.dart' as app_model;

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Set global status bar style
  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.light,
      statusBarBrightness: Brightness.dark,
      systemNavigationBarColor: Colors.transparent,
      systemNavigationBarIconBrightness: Brightness.light,
    ),
  );
 /* await Supabase.initialize(
    url: '',
    anonKey:
    ' ',
  );*/

  await Supabase.initialize(
    url: '',
    anonKey:
    '',
  );

  final authRepository = AuthRepositoryImpl();
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => ThemeProvider()),
        ChangeNotifierProvider(create: (_) => UserProvider()),
        ChangeNotifierProvider(create: (_) => LanguageProvider()),
        ChangeNotifierProvider(create: (_) => MatchProvider()),
        ChangeNotifierProvider(create: (_) => ChatProvider()),
        ChangeNotifierProvider(create: (_) => DiscoveryProvider()),
        ChangeNotifierProvider(
          create: (_) => AuthProvider(
            loginUseCase: LoginUseCase(authRepository),
            signUpUseCase: SignUpUseCase(authRepository),
            signOutUseCase: SignOutUseCase(authRepository),
          ),
        ),
      ],
      child: const LocalizedApp(),
    ),
  );
}
// App Router
class AppRouter {
  static final GoRouter router = GoRouter(
    initialLocation: '/splash',
    routes: [
      GoRoute(path: '/splash', name: 'splash', builder: (context, state) => const SplashScreen()),
      GoRoute(path: '/auth', name: 'auth', builder: (context, state) => const AuthGate()),
      GoRoute(path: '/', name: 'main', builder: (context, state) => const MainNavigationScreen()),
      GoRoute(path: '/discovery', name: 'discovery', builder: (context, state) => const DiscoveryScreen()),
      GoRoute(path: '/matches', name: 'matches', builder: (context, state) => const MatchesScreen()),
      GoRoute(path: '/chat', name: 'chat', builder: (context, state) => const ChatListScreen()),
      GoRoute(
        path: '/chat/:userId',
        name: 'individual_chat',
        builder: (context, state) {
          final userId = state.pathParameters['userId']!;
          return IndividualChatScreen(matchUserId: userId);
        },
      ),
      GoRoute(path: '/profile', name: 'profile', builder: (context, state) => const ProfileScreen()),
      GoRoute(path: '/settings', name: 'settings', builder: (context, state) => const SettingsScreen()),
    ],
    errorBuilder: (context, state) => Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text('Page not found', style: Theme.of(context).textTheme.headlineSmall),
            const SizedBox(height: 8),
            Text('Error: ${state.error}', style: Theme.of(context).textTheme.bodyMedium),
            const SizedBox(height: 16),
            ElevatedButton(onPressed: () => context.go('/'), child: const Text('Go Home')),
          ],
        ),
      ),
    ),
  );
}


class AuthRepositoryImpl implements AuthRepository {
  final supabase = Supabase.instance.client;
  final AuthLocalDataSource _localDataSource = AuthLocalDataSource();

  AuthRepositoryImpl();

  @override
  Future<bool> login(String email, String password) async {
    try {
      final response = await supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );

      if (response.user != null) {
        await _localDataSource.saveCredentials(email, password);
        return true;
      }
      return false;
    } catch (e) {
      if (kDebugMode) {
        print('Login error: $e');
      }
      return false;
    }
  }

  @override
  Future<bool> signup(String email, String password, String name, Map<String, dynamic> userData) async {
    try {
      final response = await supabase.auth.signUp(
        email: email,
        password: password,
        data: {'name': name},
      );

      final userId = response.user?.id;
      if (userId != null) {
        // 2. Create complete user profile with all AppUser data
        final completeUserData = {
          'id': userId,
          'email': email,
          'name': userData['name'] ?? '',
          'age': userData['age'] ?? 0,
          'gender': userData['gender'] ?? '',
          'bio': userData['bio'] ?? '',
          'photos': userData['photos'] ?? [],
          'location': userData['location'] ?? '',
          'profession': userData['profession'] ?? '',
          'education': userData['education'] ?? '',
          'religion': userData['religion'] ?? '',
          'marital_status': userData['marital_status'] ?? '',
          'has_children': userData['has_children'] ?? false,
          'wants_children': userData['wants_children'] ?? false,
          'interests': userData['interests'] ?? [],
          'avatar': userData['avatar'] ?? 0,
          'is_verified': false,
          'height': userData['height'] ?? 0.0,
          'smoking_habits': userData['smoking_habits'] ?? 'Never',
          'drinking_habits': userData['drinking_habits'] ?? 'Never',
          'exercise_habits': userData['exercise_habits'] ?? 'Occasionally',
          'relationship_goals': userData['relationship_goals'] ?? 'Long-term',
          'created_at': DateTime.now().toIso8601String(),
          'updated_at': DateTime.now().toIso8601String(),
        };

        // 3. Insert into users table (make sure your Supabase has this table)
        final profileResponse = await supabase
            .from('users')
            .insert(completeUserData);
            //.execute();

        if (profileResponse.error != null) {
          if (kDebugMode) {
            print('Profile creation error: ${profileResponse.error}');
          }
          // Optional: Delete the auth user if profile creation fails
          // await supabase.auth.admin.deleteUser(userId);
          return false;
        }

        await _localDataSource.saveCredentials(email, password);
        return true;
      }
      return false;
    } catch (e) {
      if (kDebugMode) {
        print('Signup error: $e');
      }
      return false;
    }
  }


  @override
  Future<bool> hasSession() async {
    return supabase.auth.currentSession != null;
  }

  @override
  Future<void> logout() async {
    await supabase.auth.signOut();
    await _localDataSource.clearCredentials();
  }
}

// Local Data Source
class AuthLocalDataSource {
  final FlutterSecureStorage _storage = const FlutterSecureStorage();

  static const String _keyEmail = 'user_email';
  static const String _keyPassword = 'user_password';

  Future<void> saveCredentials(String email, String password) async {
    await _storage.write(key: _keyEmail, value: email);
    await _storage.write(key: _keyPassword, value: password);
  }

  Future<Map<String, String?>> getCredentials() async {
    final email = await _storage.read(key: _keyEmail);
    final password = await _storage.read(key: _keyPassword);
    return {'email': email, 'password': password};
  }

  Future<void> clearCredentials() async {
    await _storage.delete(key: _keyEmail);
    await _storage.delete(key: _keyPassword);
  }

  Future<bool> hasSession() async {
    final email = await _storage.read(key: _keyEmail);
    final password = await _storage.read(key: _keyPassword);
    return email != null && password != null;
  }
}
// Authentication Repository
abstract class AuthRepository {
  Future<bool> login(String email, String password);
  Future<bool> signup(String email, String password, String name,Map<String, dynamic> userData);
  Future<bool> hasSession();
  Future<void> logout();
}
// Use Cases
class LoginUseCase {
  final AuthRepository repository;
  LoginUseCase(this.repository);

  Future<bool> call(String email, String password) {
    return repository.login(email, password);
  }
}

class SignOutUseCase {
  final AuthRepository repository;
  SignOutUseCase(this.repository);

  Future<void> call() async {
    await repository.logout();
  }
}

class SignUpUseCase {
  final AuthRepository repository;
  SignUpUseCase(this.repository);

  Future<bool> call(String email, String password, String name, Map<String, dynamic> userData) {
    return repository.signup(email, password, name,userData);
  }
}
// Auth Gate
class AuthGate extends StatefulWidget {
  const AuthGate({Key? key}) : super(key: key);

  @override
  State<AuthGate> createState() => _AuthGateState();
}

class _AuthGateState extends State<AuthGate> {
  bool showLogin = true;

  void toggle() => setState(() => showLogin = !showLogin);

  @override
  Widget build(BuildContext context) {
    return showLogin
        ? LoginScreen(onSignUpTap: toggle)
        : SignUpScreen(onLoginTap: toggle);
  }
}
// Providers
class AuthProvider extends ChangeNotifier {
  final LoginUseCase loginUseCase;
  final SignUpUseCase signUpUseCase;
  final SignOutUseCase signOutUseCase;

  bool _isLoading = false;
  String? _error;
  User? _user;
  AppUser? _appUser;

  bool get isLoading => _isLoading;
  String? get error => _error;
  User? get user => _user;
  AppUser? get appUser => _appUser;
  AuthProvider({
    required this.loginUseCase,
    required this.signUpUseCase,
    required this.signOutUseCase,
  });

  Future<bool> login(String email, String password) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    final success = await loginUseCase(email, password);
    _isLoading = false;

    if (!success) {
      _error = 'Invalid credentials or validation failed.';
      notifyListeners();
      return false;
    }

    _user = Supabase.instance.client.auth.currentUser;
    notifyListeners();
    return true;
  }

// In your AuthProvider
  Future<bool> signup(String email, String password, Map<String, dynamic> userData) async {

      _isLoading = true;
      _error = null;
      notifyListeners();

      final success = await signUpUseCase(email, password, userData ['name'], userData);
      _isLoading = false;

      if (!success) {
        _error = 'Signup failed. Check your input.';
        notifyListeners();
        return false;
      }

      _user = Supabase.instance.client.auth.currentUser;

      // Create AppUser object from the response
      if (userData['id'] != null) {
        _appUser = AppUser.fromJson(userData);
      } else {
        _error = 'Signup failed. Check your input.';
        notifyListeners();
        return false;
      }


      notifyListeners();
      return true;
    }
/*
  Future<bool> signup(String email, String password, String name) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    final success = await signUpUseCase(email, password, name);
    _isLoading = false;

    if (!success) {
      _error = 'Signup failed. Check your input.';
      notifyListeners();
      return false;
    }

    _user = Supabase.instance.client.auth.currentUser;
    notifyListeners();
    return true;
  }
*/
  Future<void> signOut() async {
    await signOutUseCase();
    _user = null;
    notifyListeners();
  }

  Future<bool> hasSession() async {
    return await loginUseCase.repository.hasSession();
  }
  void setAppUser(AppUser appUser) {
    _appUser = appUser;
    notifyListeners();
  }

  set error(String? value) {
    _error = value;
    notifyListeners();
  }

  void clearError() {
    _error = null;
    notifyListeners();
  }
}

// Login Screen
class LoginScreen extends StatefulWidget {
  final VoidCallback onSignUpTap;
  const LoginScreen({Key? key, required this.onSignUpTap}) : super(key: key);

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    return Scaffold(
      backgroundColor: const Color(0xFF1A0F0F),
      body: Stack(
        children: [
          Positioned(
            top: -100,
            right: -100,
            child: Container(
              width: 300,
              height: 300,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: RadialGradient(
                  colors: [Colors.red.withOpacity(0.2), Colors.transparent],
                ),
              ),
            ),
          ),

          Center(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(24),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    margin: const EdgeInsets.only(bottom: 40),
                    child: const Text(
                      'الكنز',
                      style: TextStyle(
                        fontFamily: 'TufuliArabic',
                        fontSize: 42,
                        fontWeight: FontWeight.bold,
                        color: Colors.amber,
                        letterSpacing: 4,
                        shadows: [Shadow(blurRadius: 10, color: Colors.red)],
                      ),
                    ),
                  ),

                  Container(
                    width: double.infinity,
                    constraints: const BoxConstraints(maxWidth: 500),
                    decoration: BoxDecoration(
                      color: const Color(0xFF231818),
                      borderRadius: BorderRadius.circular(20),
                      border: Border.all(color: Colors.amber.withOpacity(0.2)),
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.5),
                          blurRadius: 20,
                          spreadRadius: 5,
                        ),
                      ],
                    ),
                    padding: const EdgeInsets.all(32),
                    child: Form(
                      key: _formKey,
                      child: Column(
                        children: [
                          Text(
                            AppLocalizations.of(context, 'login'),
                            style: TextStyle(
                              fontSize: 24,
                              fontWeight: FontWeight.bold,
                              color: Colors.amber[300],
                              letterSpacing: 2,
                            ),
                          ),
                          const SizedBox(height: 32),

                          TextFormField(
                            controller: _emailController,
                            decoration: InputDecoration(
                              labelText: AppLocalizations.of(context, 'email'),
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              prefixIcon: Icon(Icons.email, color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return AppLocalizations.of(context, 'enter_email');
                              }
                              if (!RegExp(r"^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$").hasMatch(value)) {
                                return AppLocalizations.of(context, 'invalid_email');
                              }
                              return null;
                            },
                          ),
                          const SizedBox(height: 20),

                          TextFormField(
                            controller: _passwordController,
                            decoration: InputDecoration(
                              labelText: AppLocalizations.of(context, 'password'),
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              prefixIcon: Icon(Icons.lock, color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                            obscureText: true,
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return AppLocalizations.of(context, 'enter_password');
                              }
                              if (value.length < 6) {
                                return AppLocalizations.of(context, 'password_too_short');
                              }
                              return null;
                            },
                          ),
                          const SizedBox(height: 20),

                          SizedBox(
                            width: double.infinity,
                            child: ElevatedButton(
                              style: ElevatedButton.styleFrom(
                                backgroundColor: Colors.amber,
                                foregroundColor: const Color(0xFF1A0F0F),
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                                padding: const EdgeInsets.symmetric(vertical: 18),
                                elevation: 5,
                              ),
                              onPressed: authProvider.isLoading ? null : () => _handleLogin(context, authProvider),
                              child: authProvider.isLoading
                                  ? const CircularProgressIndicator(color: Color(0xFF1A0F0F))
                                  : Text(
                                AppLocalizations.of(context, 'login'),
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                  letterSpacing: 1.5,
                                ),
                              ),
                            ),
                          ),

                          const SizedBox(height: 24),

                          TextButton(
                            onPressed: widget.onSignUpTap,
                            child: RichText(
                              text: TextSpan(
                                text: AppLocalizations.of(context, 'new_user'),
                                style: TextStyle(color: Colors.white.withOpacity(0.7)),
                                children: [
                                  TextSpan(
                                    text: AppLocalizations.of(context, 'sign_up'),
                                    style: const TextStyle(
                                      color: Colors.amber,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _handleLogin(BuildContext context, AuthProvider authProvider) async {
    if (_formKey.currentState?.validate() ?? false) {
      final success = await authProvider.login(_emailController.text, _passwordController.text);
      if (success) {
        CustomSnackBar.show(
          context,
          message: AppLocalizations.of(context, 'login_success'),
          type: CustomSnackBarType.success,
        );
        if (context.mounted) context.go('/');
      } else if (authProvider.error != null) {
        CustomSnackBar.show(
          context,
          message: authProvider.error!,
          type: CustomSnackBarType.error,
        );
      }
    }
  }
}
// SignUp Screen
class SignUpScreen extends StatefulWidget {
  final VoidCallback onLoginTap;
  const SignUpScreen({Key? key, required this.onLoginTap}) : super(key: key);

  @override
  State<SignUpScreen> createState() => _SignUpScreenState();
}

class _SignUpScreenState extends State<SignUpScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _ageController = TextEditingController();
  final _bioController = TextEditingController();
  final _locationController = TextEditingController();
  final _professionController = TextEditingController();
  final _educationController = TextEditingController();
  final _heightController = TextEditingController();

  String? _selectedGender;
  String? _selectedReligion;
  String? _selectedMaritalStatus;
  String? _selectedSmokingHabits;
  String? _selectedDrinkingHabits;
  String? _selectedExerciseHabits;
  String? _selectedRelationshipGoals;

  bool _hasChildren = false;
  bool _wantsChildren = false;

  final List<String> _interests = [];
  final TextEditingController _interestController = TextEditingController();

  @override
  void dispose() {
    _nameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    _ageController.dispose();
    _bioController.dispose();
    _locationController.dispose();
    _professionController.dispose();
    _educationController.dispose();
    _heightController.dispose();
    _interestController.dispose();
    super.dispose();
  }

  void _addInterest() {
    if (_interestController.text.trim().isNotEmpty) {
      setState(() {
        _interests.add(_interestController.text.trim());
        _interestController.clear();
      });
    }
  }

  void _removeInterest(String interest) {
    setState(() {
      _interests.remove(interest);
    });
  }

  Future<void> _handleSignUp(BuildContext context, AuthProvider authProvider) async {
    if (_formKey.currentState?.validate() ?? false) {
      if (_selectedGender == null) {
        CustomSnackBar.show(
          context,
          message: 'Please select your gender',
          type: CustomSnackBarType.error,
        );
        return;
      }

      // Create AppUser object
      final userData = {
        'email': _emailController.text.trim(),
        'name': _nameController.text.trim(),
        'age': int.tryParse(_ageController.text) ?? 0,
        'gender': _selectedGender!,
        'bio': _bioController.text.trim(),
        'photos': [],
        'location': _locationController.text.trim(),
        'profession': _professionController.text.trim(),
        'education': _educationController.text.trim(),
        'religion': _selectedReligion ?? '',
        'marital_status': _selectedMaritalStatus ?? '',
        'has_children': _hasChildren,
        'wants_children': _wantsChildren,
        'interests': _interests,
        'avatar': 0,
        'is_verified': false,
        'height': double.tryParse(_heightController.text) ?? 0.0,
        'smoking_habits': _selectedSmokingHabits ?? 'Never',
        'drinking_habits': _selectedDrinkingHabits ?? 'Never',
        'exercise_habits': _selectedExerciseHabits ?? 'Occasionally',
        'relationship_goals': _selectedRelationshipGoals ?? 'Long-term',
      };

      final success = await authProvider.signup(
        _emailController.text.trim(),
        _passwordController.text.trim(),
        userData ,
      );

      if (success) {
        CustomSnackBar.show(
          context,
          message: AppLocalizations.of(context, 'signup_success'),
          type: CustomSnackBarType.success,
        );
        if (context.mounted) context.go('/');
      } else if (authProvider.error != null) {
        CustomSnackBar.show(
          context,
          message: authProvider.error!,
          type: CustomSnackBarType.error,
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);

    return Scaffold(
      backgroundColor: const Color(0xFF1A0F0F),
      body: Stack(
        children: [
          Positioned(
            top: -100,
            left: -100,
            child: Container(
              width: 300,
              height: 300,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: RadialGradient(
                  colors: [Colors.amber.withOpacity(0.2), Colors.transparent],
                ),
              ),
            ),
          ),

          Center(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(24),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    margin: const EdgeInsets.only(bottom: 40),
                    child: const Text(
                      'الكنز',
                      style: TextStyle(
                        fontFamily: 'TufuliArabic',
                        fontSize: 42,
                        fontWeight: FontWeight.bold,
                        color: Colors.amber,
                        letterSpacing: 4,
                        shadows: [Shadow(blurRadius: 10, color: Colors.red)],
                      ),
                    ),
                  ),

                  Container(
                    width: double.infinity,
                    constraints: const BoxConstraints(maxWidth: 500),
                    decoration: BoxDecoration(
                      color: const Color(0xFF231818),
                      borderRadius: BorderRadius.circular(20),
                      border: Border.all(color: Colors.amber.withOpacity(0.2)),
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.5),
                          blurRadius: 20,
                          spreadRadius: 5,
                        ),
                      ],
                    ),
                    padding: const EdgeInsets.all(32),
                    child: Form(
                      key: _formKey,
                      child: Column(
                        children: [
                          Text(
                            AppLocalizations.of(context, 'signup'),
                            style: TextStyle(
                              fontSize: 24,
                              fontWeight: FontWeight.bold,
                              color: Colors.amber[300],
                              letterSpacing: 2,

                            ),

                          ),
                          const SizedBox(height: 32),

                          // Basic Information Section
                          _buildSectionHeader('Basic Information'),
                          const SizedBox(height: 16),

                          TextFormField(
                            controller: _nameController,
                            decoration: InputDecoration(
                              labelText: AppLocalizations.of(context, 'display_name'),
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              prefixIcon: Icon(Icons.person, color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return AppLocalizations.of(context, 'enter_name');
                              }
                              return null;
                            },
                          ),
                          const SizedBox(height: 16),

                          TextFormField(
                            controller: _emailController,
                            decoration: InputDecoration(
                              labelText: AppLocalizations.of(context, 'email'),
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              prefixIcon: Icon(Icons.email, color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return AppLocalizations.of(context, 'enter_email');
                              }
                              if (!RegExp(r"^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$").hasMatch(value)) {
                                return AppLocalizations.of(context, 'invalid_email');
                              }
                              return null;
                            },
                          ),
                          const SizedBox(height: 16),

                          TextFormField(
                            controller: _passwordController,
                            decoration: InputDecoration(
                              labelText: AppLocalizations.of(context, 'password'),
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              prefixIcon: Icon(Icons.lock, color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                            obscureText: true,
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return AppLocalizations.of(context, 'enter_password');
                              }
                              if (value.length < 6) {
                                return AppLocalizations.of(context, 'password_too_short');
                              }
                              return null;
                            },
                          ),
                          const SizedBox(height: 16),

                          // Personal Details Section
                          _buildSectionHeader('Personal Details'),
                          const SizedBox(height: 16),

                          Row(
                            children: [
                              Expanded(
                                child: TextFormField(
                                  controller: _ageController,
                                  keyboardType: TextInputType.number,
                                  decoration: InputDecoration(
                                    labelText: 'Age',
                                    labelStyle: TextStyle(color: Colors.amber[200]),
                                    prefixIcon: Icon(Icons.cake, color: Colors.amber[200]),
                                    filled: true,
                                    fillColor: const Color(0xFF2A1E1E),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                      borderSide: BorderSide.none,
                                    ),
                                    contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                                  ),
                                  style: const TextStyle(color: Colors.white),
                                  validator: (value) {
                                    if (value == null || value.isEmpty) {
                                      return 'Please enter your age';
                                    }
                                    final age = int.tryParse(value);
                                    if (age == null || age < 18 || age > 100) {
                                      return 'Please enter a valid age (18-100)';
                                    }
                                    return null;
                                  },
                                ),
                              ),
                              const SizedBox(width: 16),
                              Expanded(
                                child: DropdownButtonFormField<String>(
                                  value: _selectedGender,
                                  decoration: InputDecoration(
                                    labelText: 'Gender',
                                    labelStyle: TextStyle(color: Colors.amber[200]),
                                    prefixIcon: Icon(Icons.person_outline, color: Colors.amber[200]),
                                    filled: true,
                                    fillColor: const Color(0xFF2A1E1E),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                      borderSide: BorderSide.none,
                                    ),
                                    contentPadding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
                                  ),
                                  dropdownColor: const Color(0xFF2A1E1E),
                                  style: const TextStyle(color: Colors.white),
                                  items: ['Male', 'Female', 'Other'].map((String value) {
                                    return DropdownMenuItem<String>(
                                      value: value,
                                      child: Text(value),
                                    );
                                  }).toList(),
                                  onChanged: (newValue) {
                                    setState(() {
                                      _selectedGender = newValue;
                                    });
                                  },
                                  validator: (value) {
                                    if (value == null) {
                                      return 'Please select your gender';
                                    }
                                    return null;
                                  },
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 16),

                          TextFormField(
                            controller: _heightController,
                            keyboardType: TextInputType.number,
                            decoration: InputDecoration(
                              labelText: 'Height (cm)',
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              prefixIcon: Icon(Icons.height, color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                          ),
                          const SizedBox(height: 16),

                          // Lifestyle Section
                          _buildSectionHeader('Lifestyle'),
                          const SizedBox(height: 16),

                          Row(
                            children: [
                              Expanded(
                                child: DropdownButtonFormField<String>(
                                  value: _selectedSmokingHabits,
                                  decoration: InputDecoration(
                                    labelText: 'Smoking',
                                    labelStyle: TextStyle(color: Colors.amber[200]),
                                    filled: true,
                                    fillColor: const Color(0xFF2A1E1E),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                      borderSide: BorderSide.none,
                                    ),
                                    contentPadding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
                                  ),
                                  dropdownColor: const Color(0xFF2A1E1E),
                                  style: const TextStyle(color: Colors.white),
                                  items: ['Never', 'Occasionally', 'Regularly', 'Socially'].map((String value) {
                                    return DropdownMenuItem<String>(
                                      value: value,
                                      child: Text(value),
                                    );
                                  }).toList(),
                                  onChanged: (newValue) {
                                    setState(() {
                                      _selectedSmokingHabits = newValue;
                                    });
                                  },
                                ),
                              ),
                              const SizedBox(width: 16),
                              Expanded(
                                child: DropdownButtonFormField<String>(
                                  value: _selectedDrinkingHabits,
                                  decoration: InputDecoration(
                                    labelText: 'Drinking',
                                    labelStyle: TextStyle(color: Colors.amber[200]),
                                    filled: true,
                                    fillColor: const Color(0xFF2A1E1E),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                      borderSide: BorderSide.none,
                                    ),
                                    contentPadding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
                                  ),
                                  dropdownColor: const Color(0xFF2A1E1E),
                                  style: const TextStyle(color: Colors.white),
                                  items: ['Never', 'Occasionally', 'Regularly', 'Socially'].map((String value) {
                                    return DropdownMenuItem<String>(
                                      value: value,
                                      child: Text(value),
                                    );
                                  }).toList(),
                                  onChanged: (newValue) {
                                    setState(() {
                                      _selectedDrinkingHabits = newValue;
                                    });
                                  },
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 16),

                          DropdownButtonFormField<String>(
                            value: _selectedExerciseHabits,
                            decoration: InputDecoration(
                              labelText: 'Exercise',
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
                            ),
                            dropdownColor: const Color(0xFF2A1E1E),
                            style: const TextStyle(color: Colors.white),
                            items: ['Never', 'Occasionally', 'Regularly', 'Daily'].map((String value) {
                              return DropdownMenuItem<String>(
                                value: value,
                                child: Text(value),
                              );
                            }).toList(),
                            onChanged: (newValue) {
                              setState(() {
                                _selectedExerciseHabits = newValue;
                              });
                            },
                          ),
                          const SizedBox(height: 16),

                          // Professional Information
                          _buildSectionHeader('Professional Information'),
                          const SizedBox(height: 16),

                          TextFormField(
                            controller: _professionController,
                            decoration: InputDecoration(
                              labelText: 'Profession',
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              prefixIcon: Icon(Icons.work, color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                          ),
                          const SizedBox(height: 16),

                          TextFormField(
                            controller: _educationController,
                            decoration: InputDecoration(
                              labelText: 'Education',
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              prefixIcon: Icon(Icons.school, color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                          ),
                          const SizedBox(height: 16),

                          // Additional Information
                          _buildSectionHeader('Additional Information'),
                          const SizedBox(height: 16),

                          TextFormField(
                            controller: _locationController,
                            decoration: InputDecoration(
                              labelText: 'Location',
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              prefixIcon: Icon(Icons.location_on, color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                          ),
                          const SizedBox(height: 16),

                          TextFormField(
                            controller: _bioController,
                            maxLines: 3,
                            decoration: InputDecoration(
                              labelText: 'Bio',
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              alignLabelWithHint: true,
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                            ),
                            style: const TextStyle(color: Colors.white),
                          ),
                          const SizedBox(height: 16),

                          // Interests
                          Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Interests',
                                style: TextStyle(
                                  color: Colors.amber[200],
                                  fontSize: 16,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                              const SizedBox(height: 8),
                              Row(
                                children: [
                                  Expanded(
                                    child: TextFormField(
                                      controller: _interestController,
                                      decoration: InputDecoration(
                                        hintText: 'Add an interest...',
                                        hintStyle: TextStyle(color: Colors.white54),
                                        filled: true,
                                        fillColor: const Color(0xFF2A1E1E),
                                        border: OutlineInputBorder(
                                          borderRadius: BorderRadius.circular(12),
                                          borderSide: BorderSide.none,
                                        ),
                                        contentPadding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
                                      ),
                                      style: const TextStyle(color: Colors.white),
                                      onFieldSubmitted: (_) => _addInterest(),
                                    ),
                                  ),
                                  const SizedBox(width: 8),
                                  IconButton(
                                    onPressed: _addInterest,
                                    icon: Icon(Icons.add, color: Colors.amber),
                                    style: IconButton.styleFrom(
                                      backgroundColor: const Color(0xFF2A1E1E),
                                      padding: const EdgeInsets.all(12),
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 8),
                              Wrap(
                                spacing: 8,
                                runSpacing: 8,
                                children: _interests.map((interest) {
                                  return Chip(
                                    label: Text(interest, style: TextStyle(color: Colors.white)),
                                    backgroundColor: Colors.amber.withOpacity(0.2),
                                    deleteIcon: Icon(Icons.close, size: 16, color: Colors.white),
                                    onDeleted: () => _removeInterest(interest),
                                  );
                                }).toList(),
                              ),
                            ],
                          ),
                          const SizedBox(height: 24),

                          // Relationship Preferences
                          _buildSectionHeader('Relationship Preferences'),
                          const SizedBox(height: 16),

                          DropdownButtonFormField<String>(
                            value: _selectedRelationshipGoals,
                            decoration: InputDecoration(
                              labelText: 'Relationship Goals',
                              labelStyle: TextStyle(color: Colors.amber[200]),
                              filled: true,
                              fillColor: const Color(0xFF2A1E1E),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
                            ),
                            dropdownColor: const Color(0xFF2A1E1E),
                            style: const TextStyle(color: Colors.white),
                            items: ['Long-term', 'Short-term', 'Friendship', 'Not sure'].map((String value) {
                              return DropdownMenuItem<String>(
                                value: value,
                                child: Text(value),
                              );
                            }).toList(),
                            onChanged: (newValue) {
                              setState(() {
                                _selectedRelationshipGoals = newValue;
                              });
                            },
                          ),
                          const SizedBox(height: 16),

                          Row(
                            children: [
                              Expanded(
                                child: _buildToggleOption(
                                  'Has Children',
                                  _hasChildren,
                                      (value) => setState(() => _hasChildren = value),
                                ),
                              ),
                              const SizedBox(width: 16),
                              Expanded(
                                child: _buildToggleOption(
                                  'Wants Children',
                                  _wantsChildren,
                                      (value) => setState(() => _wantsChildren = value),
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 24),

                          if (authProvider.error != null)
                            Container(
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: Colors.red[900]!.withOpacity(0.3),
                                borderRadius: BorderRadius.circular(8),
                              ),
                              child: Text(
                                authProvider.error!,
                                style: TextStyle(color: Colors.red[200]),
                              ),
                            ),

                          const SizedBox(height: 20),

                          SizedBox(
                            width: double.infinity,
                            child: ElevatedButton(
                              style: ElevatedButton.styleFrom(
                                backgroundColor: Colors.amber,
                                foregroundColor: const Color(0xFF1A0F0F),
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                                padding: const EdgeInsets.symmetric(vertical: 18),
                                elevation: 5,
                              ),
                              onPressed: authProvider.isLoading ? null : () => _handleSignUp(context, authProvider),
                              child: authProvider.isLoading
                                  ? const CircularProgressIndicator(color: Color(0xFF1A0F0F))
                                  : Text(
                                AppLocalizations.of(context, 'signup'),
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                  letterSpacing: 1.5,
                                ),
                              ),
                            ),
                          ),

                          const SizedBox(height: 24),

                          TextButton(
                            onPressed: widget.onLoginTap,
                            child: RichText(
                              text: TextSpan(
                                text: AppLocalizations.of(context, 'already_have_account'),
                                style: TextStyle(color: Colors.white.withOpacity(0.7)),
                                children: [
                                  TextSpan(
                                    text: AppLocalizations.of(context, 'login'),
                                    style: const TextStyle(
                                      color: Colors.amber,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Row(
      children: [
        Expanded(
          child: Divider(
            color: Colors.amber.withOpacity(0.3),
            thickness: 1,
          ),
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Text(
            title,
            style: TextStyle(
              color: Colors.amber[300],
              fontSize: 18,
              fontWeight: FontWeight.bold,
              letterSpacing: 1,
            ),
          ),
        ),
        Expanded(
          child: Divider(
            color: Colors.amber.withOpacity(0.3),
            thickness: 1,
          ),
        ),
      ],
    );
  }

  Widget _buildToggleOption(String title, bool value, Function(bool) onChanged) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFF2A1E1E),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            title,
            style: const TextStyle(color: Colors.white),
          ),
          Switch(
            value: value,
            onChanged: onChanged,
            activeColor: Colors.amber,
            inactiveTrackColor: Colors.grey[700],
          ),
        ],
      ),
    );
  }
}

// Localizations
class AppLocalizations {
  static final Map<String, Map<String, String>> _localizedValues = {
    'en': {
      'title': 'Matrimony Connect',
      'discover': 'Discover',
      'matches': 'Matches',
      'messages': 'Messages',
      'profile': 'Profile',
      'login': 'Login',
      'signup': 'Sign Up',
      'email': 'Email',
      'password': 'Password',
      'enter_email': 'Enter your email',
      'invalid_email': 'Invalid email',
      'enter_password': 'Enter your password',
      'password_too_short': 'Password too short',
      'new_user': 'New user? ',
      'sign_up': 'SIGN UP',
      'login_success': 'Login successful!',
      'display_name': 'Display Name',
      'enter_name': 'Enter your name',
      'signup_success': 'Signup successful!',
      'already_have_account': 'Already have an account? ',
      'settings': 'Settings',
      'dark_mode': 'Dark Mode',
      'language': 'Language',
      'logout': 'Logout',
      'cancel': 'Cancel',
      'logout_confirm': 'Are you sure you want to logout?',
      'no_matches_yet': 'No matches yet',
      'start_discovering': 'Start discovering people!',
      'no_messages_yet': 'No messages yet',
      'start_conversation': 'Start a conversation!',
      'type_message': 'Type a message...',
      'search_messages': 'Search messages...',
      'personal_info': 'Personal Information',
      'save_profile': 'Save Profile',
      'photo_gallery': 'Photo Gallery',
      'close': 'Close',
      'field_required': 'This field is required',
      'preferences': 'Preferences',
      'filters': 'Filters',
      'no_users_found': 'No users found',
      'adjust_filters': 'Try adjusting your filters',
      'unmatch': 'Unmatch',
      'unmatch_confirm': 'Are you sure you want to unmatch?',
      'message': 'Message',
      'bio': 'Bio',
      'age': 'Age',
      'location': 'Location',
      'profession': 'Profession',
      'education': 'Education',
      'name': 'Name',
    },
    'ar': {
      'title': 'الكنز',
      'discover': 'اكتشف',
      'matches': 'المطابقات',
      'messages': 'الرسائل',
      'profile': 'الملف',
      'login': 'تسجيل الدخول',
      'signup': 'إنشاء حساب',
      'email': 'البريد الإلكتروني',
      'password': 'كلمة المرور',
      'enter_email': 'أدخل بريدك الإلكتروني',
      'invalid_email': 'البريد الإلكتروني غير صالح',
      'enter_password': 'أدخل كلمة المرور',
      'password_too_short': 'كلمة المرور قصيرة جداً',
      'new_user': 'مستخدم جديد؟ ',
      'sign_up': 'سجل الآن',
      'login_success': 'تم تسجيل الدخول بنجاح!',
      'display_name': 'اسم العرض',
      'enter_name': 'أدخل اسمك',
      'signup_success': 'تم إنشاء الحساب بنجاح!',
      'already_have_account': 'لديك حساب بالفعل؟ ',
      'settings': 'الإعدادات',
      'dark_mode': 'الوضع الداكن',
      'language': 'اللغة',
      'logout': 'تسجيل الخروج',
      'cancel': 'إلغاء',
      'logout_confirm': 'هل أنت متأكد أنك تريد تسجيل الخروج؟',
      'no_matches_yet': 'لا توجد مطابقات بعد',
      'start_discovering': 'ابدأ اكتشاف الأشخاص!',
      'no_messages_yet': 'لا توجد رسائل بعد',
      'start_conversation': 'ابدأ محادثة!',
      'type_message': 'اكتب رسالة...',
      'search_messages': 'ابحث في الرسائل...',
      'personal_info': 'المعلومات الشخصية',
      'save_profile': 'حفظ الملف',
      'photo_gallery': 'معرض الصور',
      'close': 'إغلاق',
      'field_required': 'هذا الحقل مطلوب',
      'preferences': 'التفضيلات',
      'filters': 'الفلاتر',
      'no_users_found': 'لم يتم العثور على مستخدمين',
      'adjust_filters': 'حاول تعديل الفلاتر',
      'unmatch': 'إلغاء المطابقة',
      'unmatch_confirm': 'هل أنت متأكد أنك تريد إلغاء المطابقة؟',
      'message': 'رسالة',
      'bio': 'السيرة الذاتية',
      'age': 'العمر',
      'location': 'الموقع',
      'profession': 'المهنة',
      'education': 'التعليم',
      'name': 'الاسم',
    },
  };

  static String of(BuildContext context, String key) {
    final locale = Localizations.localeOf(context).languageCode;
    return _localizedValues[locale]?[key] ?? _localizedValues['en']?[key] ?? key;
  }
}
// Custom SnackBar
enum CustomSnackBarType { success, error, info }

class CustomSnackBar {
  static void show(
      BuildContext context, {
        required String message,
        CustomSnackBarType type = CustomSnackBarType.info,
        Duration duration = const Duration(seconds: 3),
      }) {
    final color = _getColor(type);
    final icon = _getIcon(type);
    final textColor = type == CustomSnackBarType.success ? const Color(0xFF3E2723) : Colors.white;
    final iconColor = type == CustomSnackBarType.success ? const Color(0xFF3E2723) : Colors.white;

    final snackBar = SnackBar(
      backgroundColor: Colors.transparent,
      elevation: 0,
      behavior: SnackBarBehavior.floating,
      duration: duration,
      content: Container(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [color.withOpacity(0.95), color.withOpacity(0.7)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          borderRadius: BorderRadius.circular(18),
          boxShadow: [
            BoxShadow(
              color: color.withOpacity(0.4),
              blurRadius: 16,
              spreadRadius: 2,
              offset: const Offset(0, 6),
            ),
          ],
          border: Border.all(color: Colors.amber.shade700, width: 2),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: iconColor, size: 28),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                message,
                style: TextStyle(
                  color: textColor,
                  fontWeight: FontWeight.bold,
                  fontSize: 18,
                  fontFamily: 'TufuliArabic',
                  shadows: [
                    const Shadow(
                      color: Colors.black54,
                      blurRadius: 4,
                      offset: Offset(1, 2),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );

    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(snackBar);
  }

  static Color _getColor(CustomSnackBarType type) {
    switch (type) {
      case CustomSnackBarType.success:
        return const Color(0xFFFFD700);
      case CustomSnackBarType.error:
        return const Color(0xFFB22222);
      case CustomSnackBarType.info:
        return const Color(0xFF1E90FF);
    }
  }

  static IconData _getIcon(CustomSnackBarType type) {
    switch (type) {
      case CustomSnackBarType.success:
        return Icons.emoji_events_rounded;
      case CustomSnackBarType.error:
        return Icons.error_rounded;
      case CustomSnackBarType.info:
        return Icons.info_rounded;
    }
  }
}

class AppLocalizationsDelegate extends LocalizationsDelegate<AppLocalizations> {
  const AppLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) => ['ar', 'en'].contains(locale.languageCode);

  @override
  Future<AppLocalizations> load(Locale locale) async =>
      SynchronousFuture<AppLocalizations>(AppLocalizations());

  @override
  bool shouldReload(AppLocalizationsDelegate old) => false;
}


// Localized App
class LocalizedApp extends StatelessWidget {
  const LocalizedApp({super.key});

  @override
  Widget build(BuildContext context) {
    final languageProvider = Provider.of<LanguageProvider>(context);

    return Directionality(
      textDirection: languageProvider.currentLanguage == 'ar' ? TextDirection.rtl : TextDirection.ltr,
      child: MaterialApp.router(
        title: 'Matrimony Connect',
        debugShowCheckedModeBanner: false,
        theme: Provider.of<ThemeProvider>(context).theme,
        darkTheme: ThemeData.dark(),
        locale: languageProvider.locale,
        supportedLocales: const [Locale('ar', ''), Locale('en', '')],
        localizationsDelegates: [
          AppLocalizationsDelegate(),
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        routerConfig: AppRouter.router,
      ),
    );
  }
}


class LanguageProvider extends ChangeNotifier {
  String _currentLanguage = 'en';

  LanguageProvider() {
    _loadLanguage();
  }

  String get currentLanguage => _currentLanguage;

  Future<void> setLanguage(String language) async {
    if (_currentLanguage != language) {
      _currentLanguage = language;
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('language', language);
      notifyListeners();
    }
  }

  Locale get locale {
    return Locale(_currentLanguage);
  }

  bool get isRTL {
    return _currentLanguage == 'ar';
  }

  Future<void> _loadLanguage() async {
    final prefs = await SharedPreferences.getInstance();
    final savedLang = prefs.getString('language');
    if (savedLang != null) {
      _currentLanguage = savedLang;
    } else {
      final deviceLocale = WidgetsBinding.instance.platformDispatcher.locale.languageCode;
      if (['ar', 'en'].contains(deviceLocale)) {
        _currentLanguage = deviceLocale;
      } else {
        _currentLanguage = 'en';
      }
    }
    notifyListeners();
  }
}
class ThemeProvider extends ChangeNotifier {
  bool _isDarkMode = true;

  bool get isDarkMode => _isDarkMode;

  void toggleTheme() {
    _isDarkMode = !_isDarkMode;
    notifyListeners();
  }

  ThemeData get theme {
    return _isDarkMode ? _darkTheme : _lightTheme;
  }

  static final _lightTheme = ThemeData(
    useMaterial3: true,
    brightness: Brightness.light,
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.amber,
      brightness: Brightness.light,
    ),
    appBarTheme: const AppBarTheme(centerTitle: true, elevation: 0),

    cardTheme: CardThemeData(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
    ),
  );

  static final _darkTheme = ThemeData(
    useMaterial3: true,
    brightness: Brightness.dark,
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.amber,
      brightness: Brightness.dark,
    ),
    scaffoldBackgroundColor: const Color(0xFF1A0F0F),
    appBarTheme: const AppBarTheme(
      centerTitle: true,
      elevation: 0,
      backgroundColor: Color(0xFF231818),
    ),
    cardTheme: CardThemeData(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
    ),
  );
}

// Splash Screen
class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> with TickerProviderStateMixin {
  late final AudioPlayer _audioPlayer;
  late AnimationController _fadeController;
  late AnimationController _scaleController;
  late AnimationController _textController;
  late AnimationController _loadingController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;
  late Animation<double> _textAnimation;
  late Animation<double> _loadingAnimation;
  // Modern Color Palette
  static const Color _deepNavy = Color(0xFF0A0F2D);
  static const Color _premiumGold = Color(0xFFD4AF37);
  static const Color _softGold = Color(0xFFFFF8E1);
  static const Color _darkCharcoal = Color(0xFF1A1A1A);
  static const Color _lightGold = Color(0xFFF4E4BC);
  static const Color _accentGold = Color(0xFFC9A227);

  @override
  void initState() {
    super.initState();
    _initializeAnimations();
    _startSplashSequence();
  }

  void _initializeAnimations() {
    _fadeController = AnimationController(duration: const Duration(milliseconds: 1800), vsync: this);
    _scaleController = AnimationController(duration: const Duration(milliseconds: 2200), vsync: this);
    _textController = AnimationController(duration: const Duration(milliseconds: 1200), vsync: this);
    _loadingController = AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);

    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(CurvedAnimation(parent: _fadeController, curve: Curves.easeInOut));
    _scaleAnimation = Tween<double>(begin: 0.8, end: 1.0).animate(CurvedAnimation(parent: _scaleController, curve: Curves.elasticOut));
    _textAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(CurvedAnimation(parent: _textController, curve: Curves.easeInOut));
    _loadingAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(CurvedAnimation(parent: _loadingController, curve: Curves.easeInOut));
  }

  Future<void> _startSplashSequence() async {
    _audioPlayer = AudioPlayer();

    // Start animations with delays
    _fadeController.forward();
    _scaleController.forward();

    await Future.delayed(const Duration(milliseconds: 800));
    _textController.forward();

    await Future.delayed(const Duration(milliseconds: 1200));
    _loadingController.forward();

    await Future.delayed(const Duration(seconds: 3));

    if (mounted) {
      final hasSession = await Provider.of<AuthProvider>(context, listen: false).hasSession();
      if (hasSession) {
        context.go('/');
      } else {
        context.go('/auth');
      }
    }
  }

  @override
  void dispose() {
    _audioPlayer.dispose();
    _fadeController.dispose();
    _scaleController.dispose();
    _textController.dispose();
    _loadingController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF1A0F0F),
      body: Container(
        width: double.infinity,
        height: double.infinity,
        decoration: const BoxDecoration(color: Color(0xFF1A0F0F)),
        child: SafeArea(
          child: Column(
            children: [
              const Spacer(),
              AnimatedBuilder(
                animation: Listenable.merge([_fadeController, _scaleController]),
                builder: (context, child) {
                  return Transform.scale(
                    scale: _scaleAnimation.value,
                    child: Opacity(
                      opacity: _fadeAnimation.value,
                      child: Column(
                        children: [
                          Container(
                            width: 350,
                            height: 350,
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(20),
                              boxShadow: [
                                BoxShadow(
                                  color: const Color(0xFFFFD700).withOpacity(0.3),
                                  blurRadius: 30,
                                  spreadRadius: 5,
                                ),
                              ],
                            ),
                            child: ClipRRect(
                              borderRadius: BorderRadius.circular(20),
                              child: Lottie.asset(
                                'assets/lottie/splash.json',
                                width: 350,
                                height: 350,
                                repeat: false,
                                fit: BoxFit.contain,
                                errorBuilder: (context, error, stackTrace) {
                                  return Container(
                                    color: Colors.amber,
                                    child: const Icon(Icons.favorite, size: 100, color: Colors.white),
                                  );
                                },
                              ),
                            ),
                          ),
                          const SizedBox(height: 30),
                          AnimatedBuilder(
                            animation: _textController,
                            builder: (context, child) {
                              return Transform.translate(
                                offset: Offset(0, 20 * (1 - _textAnimation.value)),
                                child: Opacity(
                                  opacity: _textAnimation.value,
                                  child: Container(
                                    padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15),
                                    decoration: BoxDecoration(
                                      gradient: const LinearGradient(colors: [Color(0xFFFFD700), Color(0xFFFFA500)]),
                                      borderRadius: BorderRadius.circular(20),
                                      border: Border.all(color: const Color(0xFFFF4500), width: 2),
                                      boxShadow: [
                                        BoxShadow(
                                          color: const Color(0xFFFFD700).withOpacity(0.5),
                                          blurRadius: 15,
                                          spreadRadius: 2,
                                        ),
                                      ],
                                    ),
                                    child: const Text(
                                      'الكنز',
                                      style: TextStyle(
                                        fontFamily: 'TufuliArabic',
                                        fontSize: 42,
                                        fontWeight: FontWeight.bold,
                                        color: Color(0xFF8B0000),
                                        letterSpacing: 3,
                                        shadows: [
                                          Shadow(offset: Offset(1, 1), blurRadius: 3, color: Color(0xFF000000)),
                                        ],
                                      ),
                                    ),
                                  ),
                                ),
                              );
                            },
                          ),
                        ],
                      ),
                    ),
                  );
                },
              ),
              const Spacer(),
              AnimatedBuilder(
                animation: _loadingController,
                builder: (context, child) {
                  return Opacity(
                    opacity: _loadingAnimation.value,
                    child: Padding(
                      padding: const EdgeInsets.only(bottom: 50),
                      child: Column(
                        children: [
                          Container(
                            width: 200,
                            height: 8,
                            decoration: BoxDecoration(
                              color: const Color(0xFF2A1A1A),
                              borderRadius: BorderRadius.circular(4),
                              border: Border.all(color: const Color(0xFFFFD700), width: 1),
                            ),
                            child: ClipRRect(
                              borderRadius: BorderRadius.circular(4),
                              child: LinearProgressIndicator(
                                backgroundColor: Colors.transparent,
                                valueColor: const AlwaysStoppedAnimation<Color>(Color(0xFFFFD700)),
                                minHeight: 8,
                              ),
                            ),
                          ),
                          const SizedBox(height: 15),
                          const Text(
                            'جاري التحميل...',
                            style: TextStyle(
                              fontFamily: 'TufuliArabic',
                              fontSize: 16,
                              color: Color(0xFFFFD700),
                              fontWeight: FontWeight.w600,
                              shadows: [
                                Shadow(offset: Offset(1, 1), blurRadius: 2, color: Colors.black54),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}
// User model with complete properties
class AppUser {
  final String id;
  final String email;
  final String name;
  final int age;
  final String gender;
  final String bio;
  final List<String> photos;
  final String location;
  final String profession;
  final String education;
  final String religion;
  final String maritalStatus;
  final bool hasChildren;
  final bool wantsChildren;
  final List<String> interests;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int avatar;
  final bool isVerified;
  final double height;
  final String smokingHabits;
  final String drinkingHabits;
  final String exerciseHabits;
  final String relationshipGoals;

  // Add new properties for enhanced matching
  final double compatibilityScore;
  final bool isOnline;
  final DateTime lastActive;
  final List<String> blockedUsers;
  final Map<String, dynamic> preferences;



  AppUser({
    required this.id,
    required this.email,
    required this.name,
    required this.age,
    required this.gender,
    required this.bio,
    required this.photos,
    required this.location,
    required this.profession,
    required this.education,
    required this.religion,
    required this.maritalStatus,
    required this.hasChildren,
    required this.wantsChildren,
    required this.interests,
    required this.createdAt,
    required this.updatedAt,
    required this.avatar,
    this.isVerified = false,
    this.height = 0.0,
    this.smokingHabits = 'Never',
    this.drinkingHabits = 'Never',
    this.exerciseHabits = 'Occasionally',
    this.relationshipGoals = 'Long-term',

    // Add new properties for enhanced matching
    this.compatibilityScore = 0.0,
    this.isOnline = false,
    DateTime? lastActive,
    this.blockedUsers = const [],
    this.preferences = const {},
  }) : lastActive = lastActive ?? DateTime.now();

  factory AppUser.fromJson(Map<String, dynamic> json) {
    return AppUser(
      id: json['id'] ?? '',
      email: json['email'] ?? '',
      name: json['name'] ?? json['username'] ?? 'Unknown',
      age: json['age'] ?? 0,
      gender: json['gender'] ?? '',
      bio: json['bio'] ?? '',
      photos: List<String>.from(json['photos'] ?? []),
      location: json['location'] ?? '',
      profession: json['profession'] ?? '',
      education: json['education'] ?? '',
      religion: json['religion'] ?? '',
      maritalStatus: json['marital_status'] ?? '',
      hasChildren: json['has_children'] ?? false,
      wantsChildren: json['wants_children'] ?? false,
      interests: List<String>.from(json['interests'] ?? []),
      avatar: json['avatar'] ?? 0,
      isVerified: json['is_verified'] ?? false,
      height: (json['height'] ?? 0.0).toDouble(),
      smokingHabits: json['smoking_habits'] ?? 'Never',
      drinkingHabits: json['drinking_habits'] ?? 'Never',
      exerciseHabits: json['exercise_habits'] ?? 'Occasionally',
      relationshipGoals: json['relationship_goals'] ?? 'Long-term',
      createdAt: DateTime.parse(json['created_at'] ?? DateTime.now().toIso8601String()),
      updatedAt: DateTime.parse(json['updated_at'] ?? DateTime.now().toIso8601String()),

      // Add new properties for enhanced matching
      compatibilityScore: (json['compatibility_score'] ?? 0.0).toDouble(),
      isOnline: json['is_online'] ?? false,
      lastActive: DateTime.parse(json['last_active'] ?? DateTime.now().toIso8601String()),
      blockedUsers: List<String>.from(json['blocked_users'] ?? []),
      preferences: Map<String, dynamic>.from(json['preferences'] ?? {}),
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'name': name,
    'age': age,
    'gender': gender,
    'bio': bio,
    'photos': photos,
    'location': location,
    'profession': profession,
    'education': education,
    'religion': religion,
    'marital_status': maritalStatus,
    'has_children': hasChildren,
    'wants_children': wantsChildren,
    'interests': interests,
    'avatar': avatar,
    'is_verified': isVerified,
    'height': height,
    'smoking_habits': smokingHabits,
    'drinking_habits': drinkingHabits,
    'exercise_habits': exerciseHabits,
    'relationship_goals': relationshipGoals,
    'created_at': createdAt.toIso8601String(),
    'updated_at': updatedAt.toIso8601String(),


// Add new properties for enhanced matching
    'compatibility_score': compatibilityScore,
    'is_online': isOnline,
    'last_active': lastActive.toIso8601String(),
    'blocked_users': blockedUsers,
    'preferences': preferences,
  };

  AppUser copyWith({
    String? id,
    String? email,
    String? name,
    int? age,
    String? gender,
    String? bio,
    List<String>? photos,
    String? location,
    String? profession,
    String? education,
    String? religion,
    String? maritalStatus,
    bool? hasChildren,
    bool? wantsChildren,
    List<String>? interests,
    DateTime? createdAt,
    DateTime? updatedAt,
    int? avatar,
    bool? isVerified,
    double? height,
    String? smokingHabits,
    String? drinkingHabits,
    String? exerciseHabits,
    String? relationshipGoals,

//new enhanced
    double? compatibilityScore,
    bool? isOnline,
    DateTime? lastActive,
    List<String>? blockedUsers,
    Map<String, dynamic>? preferences,
  }) {
    return AppUser(
      id: id ?? this.id,
      email: email ?? this.email,
      name: name ?? this.name,
      age: age ?? this.age,
      gender: gender ?? this.gender,
      bio: bio ?? this.bio,
      photos: photos ?? this.photos,
      location: location ?? this.location,
      profession: profession ?? this.profession,
      education: education ?? this.education,
      religion: religion ?? this.religion,
      maritalStatus: maritalStatus ?? this.maritalStatus,
      hasChildren: hasChildren ?? this.hasChildren,
      wantsChildren: wantsChildren ?? this.wantsChildren,
      interests: interests ?? this.interests,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      avatar: avatar ?? this.avatar,
      isVerified: isVerified ?? this.isVerified,
      height: height ?? this.height,
      smokingHabits: smokingHabits ?? this.smokingHabits,
      drinkingHabits: drinkingHabits ?? this.drinkingHabits,
      exerciseHabits: exerciseHabits ?? this.exerciseHabits,
      relationshipGoals: relationshipGoals ?? this.relationshipGoals,

      //new enhanced
      compatibilityScore: compatibilityScore ?? this.compatibilityScore,
      isOnline: isOnline ?? this.isOnline,
      lastActive: lastActive ?? this.lastActive,
      blockedUsers: blockedUsers ?? this.blockedUsers,
      preferences: preferences ?? this.preferences,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
          other is AppUser &&
              runtimeType == other.runtimeType &&
              id == other.id;

  @override
  int get hashCode => id.hashCode;
}
//final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();
// Profile Screen
class ProfileScreen extends StatefulWidget {
  const ProfileScreen({super.key});

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {

  final ImagePicker _imagePicker = ImagePicker();
  final _formKey = GlobalKey<FormState>();
  final supabase = Supabase.instance.client;

  late TextEditingController _nameController;
  late TextEditingController _ageController;
  late TextEditingController _bioController;
  late TextEditingController _locationController;
  late TextEditingController _professionController;
  late TextEditingController _educationController;

  // New controllers for enhanced profile
  late TextEditingController _heightController;
  late TextEditingController _interestsController;
  String _selectedGender = '';
  String _selectedReligion = '';
  String _selectedMaritalStatus = '';
  String _selectedSmokingHabits = 'Never';
  String _selectedDrinkingHabits = 'Never';
  String _selectedExerciseHabits = 'Occasionally';
  String _selectedRelationshipGoals = 'Long-term';
  bool _hasChildren = false;
  bool _wantsChildren = false;
  List<String> _selectedInterests = [];

  @override
  void initState() {

    super.initState();
    _initializeControllers();
    //_loadUserPreferences();
    _loadUserData();


  }
  void _loadUserData() {
    // Ensure user data is loaded
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      if (userProvider.user == null) {
        userProvider.initializeUser();
      } else {
        _initializeControllers();
      }
    });
  }
  void _initializeControllers() {
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    final user = userProvider.user;

    // Default values for dropdowns
    final defaultGender = 'Male';
    final defaultReligion = 'Not Specified';
    final defaultMaritalStatus = 'Single';
    final defaultSmoking = 'Never';
    final defaultDrinking = 'Never';
    final defaultExercise = 'Occasionally';
    final defaultRelationship = 'Long-term';

    if (user != null) {
      _nameController = TextEditingController(text: user.name);
      _ageController = TextEditingController(text: user.age.toString());
      _bioController = TextEditingController(text: user.bio);
      _locationController = TextEditingController(text: user.location);
      _professionController = TextEditingController(text: user.profession);
      _educationController = TextEditingController(text: user.education);
      _heightController = TextEditingController(text: user.height.toString());
      _interestsController = TextEditingController();

      // Use user value if valid, otherwise use default
      _selectedGender = user.gender.isNotEmpty ? user.gender : defaultGender;
      _selectedReligion = user.religion.isNotEmpty ? user.religion : defaultReligion;
      _selectedMaritalStatus = user.maritalStatus.isNotEmpty ? user.maritalStatus : defaultMaritalStatus;
      _selectedSmokingHabits = user.smokingHabits.isNotEmpty ? user.smokingHabits : defaultSmoking;
      _selectedDrinkingHabits = user.drinkingHabits.isNotEmpty ? user.drinkingHabits : defaultDrinking;
      _selectedExerciseHabits = user.exerciseHabits.isNotEmpty ? user.exerciseHabits : defaultExercise;
      _selectedRelationshipGoals = user.relationshipGoals.isNotEmpty ? user.relationshipGoals : defaultRelationship;
      _hasChildren = user.hasChildren;
      _wantsChildren = user.wantsChildren;
      _selectedInterests = List.from(user.interests);
    } else {
      // Initialize with empty values if user is null
      _nameController = TextEditingController();
      _ageController = TextEditingController();
      _bioController = TextEditingController();
      _locationController = TextEditingController();
      _professionController = TextEditingController();
      _educationController = TextEditingController();
      _heightController = TextEditingController();
      _interestsController = TextEditingController();

      // Set default values for dropdowns
      _selectedGender = defaultGender;
      _selectedReligion = defaultReligion;
      _selectedMaritalStatus = defaultMaritalStatus;
      _selectedSmokingHabits = defaultSmoking;
      _selectedDrinkingHabits = defaultDrinking;
      _selectedExerciseHabits = defaultExercise;
      _selectedRelationshipGoals = defaultRelationship;
      _hasChildren = false;
      _wantsChildren = false;
      _selectedInterests = [];
    }
  }
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Re-initialize controllers when user data changes
    final userProvider = Provider.of<UserProvider>(context);
    if (userProvider.user != null) {
      _initializeControllers();
    }
  }
  void _loadUserPreferences() async {
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    final user = userProvider.user;

    if (user != null) {
      final discoveryProvider = Provider.of<DiscoveryProvider>(context, listen: false);
      await discoveryProvider.loadSearchPreferences(user.id);
    }
  }
  @override
  void dispose() {
    _nameController.dispose();
    _ageController.dispose();
    _bioController.dispose();
    _locationController.dispose();
    _professionController.dispose();
    _educationController.dispose();
    super.dispose();
  }

  Future<void> _pickImage() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
          source: ImageSource.gallery,
          maxWidth: 800,
          maxHeight: 800,
          imageQuality: 80
      );

      if (image != null) {
        final userProvider = Provider.of<UserProvider>(context, listen: false);
        final currentUser = userProvider.user;

        if (currentUser != null) {
          // Upload image to Supabase storage
          final file = File(image.path);
          final fileExt = image.path.split('.').last;
          final fileName = '${currentUser.id}/${DateTime.now().millisecondsSinceEpoch}.$fileExt';

          await supabase.storage
              .from('user-photos')
              .upload(fileName, file);

          // Get public URL
          final imageUrl = supabase.storage
              .from('user-photos')
              .getPublicUrl(fileName);

          // Update user's photos
          final updatedPhotos = List<String>.from(currentUser.photos)..add(imageUrl);
          final updatedUser = currentUser.copyWith(photos: updatedPhotos);

          await userProvider.updateProfile(updatedUser);

          setState(() {});

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Photo uploaded successfully'), backgroundColor: Colors.green),
          );
        }
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to upload photo: $e'), backgroundColor: Colors.red),
      );
    }
  }

  void _saveProfile() async {
    if (_formKey.currentState!.validate()) {
      try {
        final userProvider = Provider.of<UserProvider>(context, listen: false);
        final currentUser = userProvider.user;

        if (currentUser != null) {
          final updatedUser = currentUser.copyWith(
            name: _nameController.text,
            age: int.tryParse(_ageController.text) ?? currentUser.age,
            bio: _bioController.text,
            location: _locationController.text,
            profession: _professionController.text,
            education: _educationController.text,
            gender: _selectedGender,
            religion: _selectedReligion,
            maritalStatus: _selectedMaritalStatus,
            hasChildren: _hasChildren,
            wantsChildren: _wantsChildren,
            interests: _selectedInterests,
            height: double.tryParse(_heightController.text) ?? currentUser.height,
            smokingHabits: _selectedSmokingHabits,
            drinkingHabits: _selectedDrinkingHabits,
            exerciseHabits: _selectedExerciseHabits,
            relationshipGoals: _selectedRelationshipGoals,
          );

          await userProvider.updateProfile(updatedUser);

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Profile updated successfully'), backgroundColor: Colors.green),
          );
        }
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to update profile: $e'), backgroundColor: Colors.red),
        );
      }
    }
  }
  void _addInterest() {
    final interest = _interestsController.text.trim();
    if (interest.isNotEmpty && !_selectedInterests.contains(interest)) {
      setState(() {
        _selectedInterests.add(interest);
        _interestsController.clear();
      });
    }
  }

  void _removeInterest(String interest) {
    setState(() {
      _selectedInterests.remove(interest);
    });
  }

  @override
  Widget build(BuildContext context) {
    final userProvider = Provider.of<UserProvider>(context);

    // Show loading indicator only when initially loading
    if (userProvider.isLoading && userProvider.user == null) {
      return const Scaffold(
        backgroundColor: Color(0xFF1A0F0F),
        body: Center(
          child: CircularProgressIndicator(color: Color(0xFFFFD700)),
        ),
      );
    }

    final user = userProvider.user;

    // If still no user after loading, show error
    if (user == null) {
      return Scaffold(
        backgroundColor: const Color(0xFF1A0F0F),
        appBar: AppBar(
          backgroundColor: const Color(0xFF231818),
          title: Text(
            AppLocalizations.of(context, 'profile'),
            style: const TextStyle(color: Color(0xFFFFD700), fontWeight: FontWeight.bold),
          ),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              const Text(
                'Failed to load profile',
                style: TextStyle(color: Colors.white, fontSize: 18),
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  userProvider.initializeUser();
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFFFFD700),
                ),
                child: const Text('Retry', style: TextStyle(color: Colors.black)),
              ),
            ],
          ),
        ),
      );
    }

    // Ensure controllers are initialized before building form
    if (_nameController.text.isEmpty && user.name.isNotEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _initializeControllers();
      });
    }

    return Scaffold(
      backgroundColor: const Color(0xFF1A0F0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF231818),
        title: Text(
            AppLocalizations.of(context, 'profile'),
            style: const TextStyle(color: Color(0xFFFFD700), fontWeight: FontWeight.bold)
        ),
        actions: [
          IconButton(
              icon: const Icon(Icons.settings, color: Color(0xFFFFD700)),
              onPressed: () => context.go('/settings')
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              _buildProfileHeader(user),
              const SizedBox(height: 24),
              _buildPersonalInfoSection(),
              const SizedBox(height: 24),
              _buildPreferencesSection(),
              const SizedBox(height: 24),
              _buildActionButtons(),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildProfileHeader(AppUser user) {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFF231818),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: const Color(0xFFFFD700).withOpacity(0.2)),
        boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.5), blurRadius: 10, spreadRadius: 2)],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          Stack(
            alignment: Alignment.bottomRight,
            children: [
              Container(
                width: 120,
                height: 120,
                decoration: BoxDecoration(shape: BoxShape.circle, border: Border.all(color: const Color(0xFFFFD700), width: 3)),
                child: user.photos.isNotEmpty
                    ? CircleAvatar(backgroundImage: NetworkImage(user.photos.first))
                    : CircleAvatar(
                  backgroundColor: Colors.grey[800],
                  child: const Icon(Icons.person, size: 50, color: Colors.grey),
                ),
              ),
              GestureDetector(
                onTap: _pickImage,
                child: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(color: Colors.black.withOpacity(0.7), shape: BoxShape.circle, border: Border.all(color: const Color(0xFFFFD700))),
                  child: const Icon(Icons.camera_alt, color: Color(0xFFFFD700), size: 20),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Text(user.name, style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Color(0xFFFFD700))),
          const SizedBox(height: 8),
          Text('${user.age} • ${user.location}', style: const TextStyle(fontSize: 16, color: Colors.white)),
          const SizedBox(height: 8),
          if (user.bio.isNotEmpty) Text(user.bio, style: const TextStyle(fontSize: 14, color: Colors.white70), textAlign: TextAlign.center),
        ],
      ),
    );
  }

  Widget _buildPersonalInfoSection() {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFF231818),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: const Color(0xFFFFD700).withOpacity(0.2)),
        boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.5), blurRadius: 10, spreadRadius: 2)],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(AppLocalizations.of(context, 'personal_info'), style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Color(0xFFFFD700))),
          const SizedBox(height: 16),
          _buildTextField(_nameController, 'name', Icons.person),
          const SizedBox(height: 12),
          _buildTextField(_ageController, 'age', Icons.cake, keyboardType: TextInputType.number),
          const SizedBox(height: 12),
          _buildTextField(_locationController, 'location', Icons.location_on),
          const SizedBox(height: 12),
          _buildTextField(_professionController, 'profession', Icons.work),
          const SizedBox(height: 12),
          _buildTextField(_educationController, 'education', Icons.school),
          const SizedBox(height: 12),
          _buildBioField(),
        ],
      ),
    );
  }

  Widget _buildPreferencesSection() {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFF231818),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: const Color(0xFFFFD700).withOpacity(0.2)),
        boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.5), blurRadius: 10, spreadRadius: 2)],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(AppLocalizations.of(context, 'preferences'), style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Color(0xFFFFD700))),
          const SizedBox(height: 16),
          // Gender
          _buildPreferenceDropdown('gender', ['Male', 'Female', 'Other'], _selectedGender, (value) {
            setState(() {
              _selectedGender = value ?? '';
            });
          }),
          const SizedBox(height: 12),
          _buildPreferenceDropdown('religion', ['Muslim', 'Christian', 'Jewish', 'Hindu', 'Buddhist', 'Other','Not Specified']
          ,  _selectedReligion, (value) {
                setState(() {
                  _selectedReligion = value ?? '';
                });
              }),
          const SizedBox(height: 12),

          // Marital Status
          _buildPreferenceDropdown('marital_status', ['Single', 'Divorced', 'Widowed', 'Separated'],
              _selectedMaritalStatus, (value) {
                setState(() {
                  _selectedMaritalStatus = value ?? '';
                });
              }),
          const SizedBox(height: 12),

          // Lifestyle preferences
          _buildPreferenceDropdown('smoking_habits', ['Never', 'Occasionally', 'Regularly', 'Socially'],
              _selectedSmokingHabits, (value) {
                setState(() {
                  _selectedSmokingHabits = value ?? 'Never';
                });
              }),
          const SizedBox(height: 12),

          _buildPreferenceDropdown('drinking_habits', ['Never', 'Occasionally', 'Regularly', 'Socially'],
              _selectedDrinkingHabits, (value) {
                setState(() {
                  _selectedDrinkingHabits = value ?? 'Never';
                });
              }),
          const SizedBox(height: 12),

          _buildPreferenceDropdown('exercise_habits', ['Never', 'Occasionally', 'Regularly', 'Daily'],
              _selectedExerciseHabits, (value) {
                setState(() {
                  _selectedExerciseHabits = value ?? 'Occasionally';
                });
              }),
          const SizedBox(height: 12),

          _buildPreferenceDropdown('relationship_goals', ['Long-term', 'Short-term', 'Friendship', 'Not Sure'],
              _selectedRelationshipGoals, (value) {
                setState(() {
                  _selectedRelationshipGoals = value ?? 'Long-term';
                });
              }),
          const SizedBox(height: 12),
          // Children preferences
          _buildPreferenceSwitch('has_children', 'Has Children', _hasChildren, (value) {
            setState(() {
              _hasChildren = value;
            });
          }),
          const SizedBox(height: 12),
          _buildPreferenceSwitch('wants_children', 'Wants Children', _wantsChildren, (value) {
            setState(() {
              _wantsChildren = value;
            });
          }),

          const SizedBox(height: 16),

          // Interests
          Text('Interests', style: const TextStyle(color: Color(0xFFFFD700), fontSize: 16)),
          const SizedBox(height: 8),
          Row(
            children: [
              Expanded(
                child: TextFormField(
                  controller: _interestsController,
                  style: const TextStyle(color: Colors.white),
                  decoration: InputDecoration(
                    hintText: 'Add interest...',
                    hintStyle: const TextStyle(color: Colors.white54),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
                    ),
                  ),
                  onFieldSubmitted: (_) => _addInterest(),
                ),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: _addInterest,
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFFFFD700),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
                child: const Icon(Icons.add, color: Colors.black),
              ),
            ],
          ),
          const SizedBox(height: 12),
          _buildInterestsChips(),
        ],
      ),
    );
  }


  Widget _buildTextField(TextEditingController controller, String labelKey, IconData icon, {TextInputType keyboardType = TextInputType.text}) {
    return TextFormField(
      controller: controller,
      style: const TextStyle(color: Colors.white),
      keyboardType: keyboardType,
      decoration: InputDecoration(
        labelText: AppLocalizations.of(context, labelKey),
        labelStyle: const TextStyle(color: Color(0xFFFFD700)),
        prefixIcon: Icon(icon, color: const Color(0xFFFFD700)),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFFFFD700)),
        ),
      ),
      validator: (value) {
        if (value == null || value.isEmpty) {
          return AppLocalizations.of(context, 'field_required');
        }
        return null;
      },
    );
  }

  Widget _buildBioField() {
    return TextFormField(
      controller: _bioController,
      style: const TextStyle(color: Colors.white),
      maxLines: 3,
      decoration: InputDecoration(
        labelText: AppLocalizations.of(context, 'bio'),
        labelStyle: const TextStyle(color: Color(0xFFFFD700)),
        prefixIcon: const Icon(Icons.description, color: Color(0xFFFFD700)),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFFFFD700)),
        ),
      ),
    );
  }

// Enhanced preference dropdowns
  Widget _buildPreferenceDropdown(String key, List<String> options, String? value, Function(String?) onChanged) {
    // Ensure value is either null or in the options list
    final validValue = options.contains(value) ? value : (options.isNotEmpty ? options.first : null);

    return DropdownButtonFormField<String>(
      value: validValue,
      dropdownColor: const Color(0xFF231818),
      style: const TextStyle(color: Colors.white),
      decoration: InputDecoration(
        labelText: AppLocalizations.of(context, key),
        labelStyle: const TextStyle(color: Color(0xFFFFD700)),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
        ),
      ),
      items: options.map((option) {
        return DropdownMenuItem(
          value: option,
          child: Text(option, style: const TextStyle(color: Colors.white)),
        );
      }).toList(),
      onChanged: onChanged,
    );
  }

  Widget _buildPreferenceSwitch(String key, String label, bool value, Function(bool) onChanged) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: const TextStyle(color: Colors.white, fontSize: 16)),
          Switch(
            value: value,
            activeColor: const Color(0xFFFFD700),
            onChanged: onChanged,
          ),
        ],
      ),
    );
  }

  Widget _buildInterestsChips() {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: _selectedInterests.map((interest) {
        return Chip(
          label: Text(interest, style: const TextStyle(color: Colors.black)),
          backgroundColor: const Color(0xFFFFD700),
          deleteIcon: const Icon(Icons.close, size: 16),
          onDeleted: () => _removeInterest(interest),
        );
      }).toList(),
    );
  }

  Widget _buildActionButtons() {
    return Row(
      children: [
        Expanded(
          child: ElevatedButton(
            onPressed: _saveProfile,
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFFFFD700),
              padding: const EdgeInsets.symmetric(vertical: 16),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
            ),
            child: Text(
              AppLocalizations.of(context, 'save_profile'),
              style: const TextStyle(color: Colors.black, fontWeight: FontWeight.bold, fontSize: 16),
            ),
          ),
        ),
        const SizedBox(width: 12),
        ElevatedButton(
          onPressed: () => _showPhotoGallery(),
          style: ElevatedButton.styleFrom(
            backgroundColor: const Color(0xFF231818),
            padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 16),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
              side: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
            ),
          ),
          child: const Icon(Icons.photo_library, color: Color(0xFFFFD700)),
        ),
      ],
    );
  }

  void _showPhotoGallery() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF231818),
        title: Text(AppLocalizations.of(context, 'photo_gallery'), style: const TextStyle(color: Color(0xFFFFD700))),
        content: SizedBox(
          width: double.maxFinite,
          child: GridView.builder(
            shrinkWrap: true,
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3, crossAxisSpacing: 8, mainAxisSpacing: 8),
            itemCount: 6,
            itemBuilder: (context, index) {
              return GestureDetector(
                onTap: _pickImage,
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.grey[800],
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: const Color(0xFFFFD700).withOpacity(0.3)),
                  ),
                  child: const Icon(Icons.add_a_photo, color: Colors.grey),
                ),
              );
            },
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(AppLocalizations.of(context, 'close'), style: const TextStyle(color: Colors.grey)),
          ),
        ],
      ),
    );
  }
}


// Settings Screen
class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF1A0F0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF231818),
        title: Text(AppLocalizations.of(context, 'settings'), style: const TextStyle(color: Colors.amber, fontWeight: FontWeight.bold)),
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _buildSection(context, AppLocalizations.of(context, 'appearance'), [
            _buildThemeSwitch(context),
            _buildLanguageSelector(context),
          ]),
          const SizedBox(height: 24),
          _buildSection(context, AppLocalizations.of(context, 'notifications'), [
            _buildNotificationSwitch(context, AppLocalizations.of(context, 'tournament_notifications'), true),
            _buildNotificationSwitch(context, AppLocalizations.of(context, 'prize_notifications'), true),
            _buildNotificationSwitch(context, AppLocalizations.of(context, 'promotion_notifications'), false),
          ]),
          const SizedBox(height: 24),
          _buildSection(context, AppLocalizations.of(context, 'account'), [
            _buildAccountOption(context, AppLocalizations.of(context, 'change_password'), Icons.lock_outline),
            _buildAccountOption(context, AppLocalizations.of(context, 'privacy_settings'), Icons.privacy_tip_outlined),
            _buildAccountOption(context, AppLocalizations.of(context, 'delete_account'), Icons.delete_outline, isDestructive: true),
          ]),
          const SizedBox(height: 24),
          _buildSection(context, AppLocalizations.of(context, 'about'), [
            _buildAboutOption(context, AppLocalizations.of(context, 'terms_of_service')),
            _buildAboutOption(context, AppLocalizations.of(context, 'privacy_policy')),
            _buildAboutOption(context, AppLocalizations.of(context, 'version'), trailing: const Text('1.0.0', style: TextStyle(color: Colors.amber))),
          ]),
          const SizedBox(height: 24),
          _buildLogoutOption(context),
        ],
      ),
    );
  }

  Widget _buildSection(BuildContext context, String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: const TextStyle(color: Colors.white, fontSize: 20, fontWeight: FontWeight.bold)),
        const SizedBox(height: 16),
        Container(
          decoration: BoxDecoration(
            color: const Color(0xFF231818),
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: Colors.amber.withOpacity(0.2)),
            boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.5), blurRadius: 10, spreadRadius: 2)],
          ),
          child: Column(children: children),
        ),
      ],
    );
  }

  Widget _buildThemeSwitch(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: const Color(0xFF231818),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.amber.withOpacity(0.2)),
        boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.2), blurRadius: 6, spreadRadius: 1)],
      ),
      child: Row(
        children: [
          const Icon(Icons.dark_mode, color: Colors.amber),
          const SizedBox(width: 16),
          Expanded(child: Text(AppLocalizations.of(context, 'dark_mode'), style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16))),
          Switch(
            value: Provider.of<ThemeProvider>(context).isDarkMode,
            activeColor: Colors.amber,
            inactiveThumbColor: Colors.grey,
            inactiveTrackColor: Colors.grey[700],
            onChanged: (value) {
              Provider.of<ThemeProvider>(context, listen: false).toggleTheme();
            },
          ),
        ],
      ),
    );
  }

  Widget _buildLanguageSelector(BuildContext context) {
    final currentLanguage = Provider.of<LanguageProvider>(context).currentLanguage;
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: const Color(0xFF231818),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.amber.withOpacity(0.2)),
        boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.2), blurRadius: 6, spreadRadius: 1)],
      ),
      child: Row(
        children: [
          const Icon(Icons.language, color: Colors.amber),
          const SizedBox(width: 16),
          Expanded(child: Text(AppLocalizations.of(context, 'language'), style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16))),
          DropdownButton<String>(
            value: currentLanguage,
            dropdownColor: const Color(0xFF231818),
            style: const TextStyle(color: Colors.amber, fontWeight: FontWeight.bold),
            underline: Container(),
            items: [
              DropdownMenuItem(value: 'en', child: Text(AppLocalizations.of(context, 'english'), style: const TextStyle(color: Colors.amber))),
              DropdownMenuItem(value: 'ar', child: Text(AppLocalizations.of(context, 'arabic'), style: const TextStyle(color: Colors.amber))),
            ],
            onChanged: (value) {
              if (value != null) {
                Provider.of<LanguageProvider>(context, listen: false).setLanguage(value);
              }
            },
          ),
        ],
      ),
    );
  }

  Widget _buildNotificationSwitch(BuildContext context, String title, bool initialValue) {
    return SwitchListTile(
      title: Text(title, style: const TextStyle(color: Colors.white)),
      value: initialValue,
      activeColor: Colors.amber,
      inactiveThumbColor: Colors.grey,
      inactiveTrackColor: Colors.grey[700],
      onChanged: (value) {},
    );
  }

  Widget _buildAccountOption(BuildContext context, String title, IconData icon, {bool isDestructive = false}) {
    return ListTile(
      leading: Icon(icon, color: isDestructive ? Colors.red : Colors.amber),
      title: Text(title, style: TextStyle(color: isDestructive ? Colors.red : Colors.white)),
      trailing: const Icon(Icons.chevron_right, color: Colors.amber),
      onTap: () {},
    );
  }

  Widget _buildAboutOption(BuildContext context, String title, {Widget? trailing}) {
    return ListTile(
      title: Text(title, style: const TextStyle(color: Colors.white)),
      trailing: trailing ?? const Icon(Icons.chevron_right, color: Colors.amber),
      onTap: () {},
    );
  }

  Widget _buildLogoutOption(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: const Color(0xFF231818),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.red.withOpacity(0.3)),
        boxShadow: [BoxShadow(color: Colors.red.withOpacity(0.08), blurRadius: 6, spreadRadius: 1)],
      ),
      child: ListTile(
        leading: const Icon(Icons.logout, color: Colors.red),
        title: Text(AppLocalizations.of(context, 'logout'), style: const TextStyle(color: Colors.red, fontWeight: FontWeight.bold)),
        onTap: () async {
          final shouldLogout = await showDialog<bool>(
            context: context,
            builder: (context) => AlertDialog(
              backgroundColor: const Color(0xFF231818),
              title: Text(AppLocalizations.of(context, 'logout'), style: const TextStyle(color: Colors.amber)),
              content: Text(AppLocalizations.of(context, 'logout_confirm'), style: const TextStyle(color: Colors.white)),
              actions: [
                TextButton(
                  child: Text(AppLocalizations.of(context, 'cancel'), style: const TextStyle(color: Colors.grey)),
                  onPressed: () => Navigator.of(context).pop(false),
                ),
                TextButton(
                  child: Text(AppLocalizations.of(context, 'logout'), style: const TextStyle(color: Colors.red)),
                  onPressed: () => Navigator.of(context).pop(true),
                ),
              ],
            ),
          );
          if (shouldLogout == true) {
            await Provider.of<AuthProvider>(context, listen: false).signOut();
            if (context.mounted) context.go('/auth');
          }
        },
      ),
    );
  }
}


class UserProvider extends ChangeNotifier {
  final FlutterSecureStorage _storage = const FlutterSecureStorage();
  final supabase = Supabase.instance.client;
  AppUser? _user;
  bool _isLoading = true;
  bool _isUpdating = false;

  AppUser? get user => _user;
  bool get isLoading => _isLoading;
  bool get isUpdating => _isUpdating;

  Future<void> initializeUser() async {
    _isLoading = true;
    notifyListeners();

    try {
      await loadUserFromCache(notify: false);
      await fetchUser();
    } catch (e) {
      if (kDebugMode) {
        print('Error initializing user: $e');
      }
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> loadUserFromCache({bool notify = true}) async {
    try {
      final data = await _storage.read(key: 'user_data');
      if (data != null) {
        final Map<String, dynamic> json = jsonDecode(data);
        _user = AppUser.fromJson(json);
        if (notify) notifyListeners();
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error parsing cached user data: $e');
      }
    }
  }

  Future<void> fetchUser() async {
    try {
      final currentUser = supabase.auth.currentUser;
      if (currentUser == null) {
        _user = null;
        notifyListeners();
        return;
      }

      final response = await supabase
          .from('users')
          .select()
          .eq('id', currentUser.id)
          .single();

      if (response != null) {
        final user = AppUser.fromJson(response);
        _user = user;
        await cacheUser(user);
        notifyListeners();
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error fetching user: $e');
      }
    }
  }

  Future<void> cacheUser(AppUser user) async {
    try {
      await _storage.write(key: 'user_data', value: jsonEncode(user.toJson()));
    } catch (e) {
      if (kDebugMode) {
        print('Error caching user: $e');
      }
    }
  }

  Future<void> updateUser(AppUser user) async {
    _user = user;
    await cacheUser(user);
    notifyListeners();
  }

  Future<void> updateAvatar(int avatarIndex) async {
    if (_user == null) return;

    try {
      _isUpdating = true;
      notifyListeners();

      await supabase
          .from('users')
          .update({'avatar': avatarIndex})
          .eq('id', _user!.id);

      final updatedUser = _user!.copyWith(avatar: avatarIndex);
      await updateUser(updatedUser);
    } catch (e) {
      if (kDebugMode) {
        print('Failed to update avatar: $e');
      }
      rethrow;
    } finally {
      _isUpdating = false;
      notifyListeners();
    }
  }

  Future<void> updateProfile(AppUser updatedUser) async {
    try {
      _isUpdating = true;
      notifyListeners();

      final updateData = {
        'name': updatedUser.name,
        'age': updatedUser.age,
        'bio': updatedUser.bio,
        'location': updatedUser.location,
        'profession': updatedUser.profession,
        'education': updatedUser.education,
        'gender': updatedUser.gender,
        'religion': updatedUser.religion,
        'marital_status': updatedUser.maritalStatus,
        'has_children': updatedUser.hasChildren,
        'wants_children': updatedUser.wantsChildren,
        'interests': updatedUser.interests,
        'height': updatedUser.height,
        'smoking_habits': updatedUser.smokingHabits,
        'drinking_habits': updatedUser.drinkingHabits,
        'exercise_habits': updatedUser.exerciseHabits,
        'relationship_goals': updatedUser.relationshipGoals,
        'photos': updatedUser.photos,
        'updated_at': DateTime.now().toIso8601String(),
      };

      await supabase
          .from('users')
          .update(updateData)
          .eq('id', updatedUser.id);

      await updateUser(updatedUser);
    } catch (e) {
      if (kDebugMode) {
        print('Failed to update profile: $e');
      }
      rethrow;
    } finally {
      _isUpdating = false;
      notifyListeners();
    }
  }

  Future<void> updateOnlineStatus(bool isOnline) async {
    if (_user == null) return;

    try {
      await supabase
          .from('users')
          .update({
        'is_online': isOnline,
        'last_active': DateTime.now().toIso8601String(),
      })
          .eq('id', _user!.id);

      final updatedUser = _user!.copyWith(
        isOnline: isOnline,
        lastActive: DateTime.now(),
      );
      await updateUser(updatedUser);
    } catch (e) {
      if (kDebugMode) {
        print('Error updating online status: $e');
      }
    }
  }

  Future<void> clearUser() async {
    _user = null;
    _isLoading = false;
    await _storage.delete(key: 'user_data');
    notifyListeners();
  }
}

// Helper to parse string Map (from toString) to Map<String, dynamic>
Map<String, dynamic> _parseUserStringToMap(String data) {
  // This is a quick hack for Map's toString, for production use jsonEncode/jsonDecode
  data = data.replaceAll(RegExp(r'[{}]'), '');
  final map = <String, dynamic>{};
  for (final entry in data.split(',')) {
    final kv = entry.split(':');
    if (kv.length == 2) {
      map[kv[0].trim()] = int.tryParse(kv[1].trim()) ?? kv[1].trim();
    }
  }
  return map;
}

// Match Provider
//updated
// Match Provider
class MatchProvider extends ChangeNotifier {
  final SupabaseClient _supabase = Supabase.instance.client;
  List<AppUser> _potentialMatches = [];
  List<Match> _matches = [];
  List<AppUser> _likedUsers = [];
  bool _isLoading = false;
  bool _isMatching = false;

  List<AppUser> get potentialMatches => _potentialMatches;
  List<Match> get matches => _matches;
  List<AppUser> get likedUsers => _likedUsers;
  bool get isLoading => _isLoading;
  bool get isMatching => _isMatching;

  Future<void> loadPotentialMatches(String currentUserId) async {
    _isLoading = true;
    notifyListeners();

    try {
      // Get user preferences first
      final userResponse = await _supabase
          .from('users')
          .select()
          .eq('id', currentUserId)
          .single();

      final currentUser = AppUser.fromJson(userResponse);

      // Build the query step by step
      var query = _supabase
          .from('users')
          .select()
          .neq('id', currentUserId);

      // Apply blocked users filter if there are any
      if (currentUser.blockedUsers.isNotEmpty) {
        query = query.not('id', 'in', '(${currentUser.blockedUsers.map((id) => "'$id'").join(',')})');
      }

      // Apply basic filters using the correct PostgrestFilterBuilder methods
      if (currentUser.preferences['min_age'] != null) {
        final minAge = currentUser.preferences['min_age'];
        query = query.filter('age', 'gte', minAge);
      }
      if (currentUser.preferences['max_age'] != null) {
        final maxAge = currentUser.preferences['max_age'];
        query = query.filter('age', 'lte', maxAge);
      }
      if (currentUser.preferences['gender'] != null &&
          currentUser.preferences['gender'] != 'any') {
        final gender = currentUser.preferences['gender'];
        query = query.eq('gender', gender);
      }

      // Apply limit at the end
      //query = query.limit(50);

      final response = await query;

      _potentialMatches = (response as List)
          .map((json) => AppUser.fromJson(json))
          .toList();

      // Calculate compatibility scores
      _calculateCompatibilityScores(currentUser);
    } catch (e) {
      if (kDebugMode) {
        print('Error loading potential matches: $e');
      }
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  void _calculateCompatibilityScores(AppUser currentUser) {
    for (var user in _potentialMatches) {
      double score = 0.0;
      int factors = 0;

      // Age compatibility
      if ((user.age - currentUser.age).abs() <= 5) {
        score += 0.2;
      }
      factors++;

      // Location compatibility
      if (user.location == currentUser.location) {
        score += 0.3;
      }
      factors++;

      // Interests compatibility
      final commonInterests = user.interests
          .where((interest) => currentUser.interests.contains(interest))
          .length;
      if (currentUser.interests.isNotEmpty) {
        score += (commonInterests / currentUser.interests.length) * 0.3;
      }
      factors++;

      // Lifestyle compatibility
      if (user.smokingHabits == currentUser.smokingHabits) score += 0.1;
      if (user.drinkingHabits == currentUser.drinkingHabits) score += 0.1;
      if (user.exerciseHabits == currentUser.exerciseHabits) score += 0.1;
      factors += 3;

      final compatibilityScore = score / factors;
      user = user.copyWith(compatibilityScore: compatibilityScore);
    }

    // Sort by compatibility score
    _potentialMatches.sort((a, b) => b.compatibilityScore.compareTo(a.compatibilityScore));
  }

  Future<void> likeUser(String currentUserId, String likedUserId) async {
    try {
      _isMatching = true;
      notifyListeners();

      await _supabase.from('likes').insert({
        'user_id': currentUserId,
        'liked_user_id': likedUserId,
        'created_at': DateTime.now().toIso8601String(),
      });

      // Check for mutual like
      final mutualLike = await _supabase
          .from('likes')
          .select()
          .eq('user_id', likedUserId)
          .eq('liked_user_id', currentUserId)
          .maybeSingle();

      if (mutualLike != null) {
        // Create match
        final matchResponse = await _supabase
            .from('matches')
            .insert({
          'user1_id': currentUserId,
          'user2_id': likedUserId,
          'created_at': DateTime.now().toIso8601String(),
        })
            .select()
            .single();

        // Get matched user details
        final userResponse = await _supabase
            .from('users')
            .select()
            .eq('id', likedUserId)
            .single();

        final matchedUser = AppUser.fromJson(userResponse);

        _matches.add(Match(
          id: matchResponse['id'],
          users: [matchedUser],
          createdAt: DateTime.now(),
          lastMessage: null,
        ));

        // Send notification for match
        await _sendMatchNotification(currentUserId, likedUserId);
      }

      _potentialMatches.removeWhere((user) => user.id == likedUserId);
      _likedUsers.add(_potentialMatches.firstWhere((user) => user.id == likedUserId));
    } catch (e) {
      if (kDebugMode) {
        print('Error liking user: $e');
      }
      rethrow;
    } finally {
      _isMatching = false;
      notifyListeners();
    }
  }

  Future<void> _sendMatchNotification(String userId1, String userId2) async {
    try {
      await _supabase.from('notifications').insert({
        'user_id': userId2,
        'type': 'match',
        'title': 'New Match!',
        'message': 'You have a new match!',
        'created_at': DateTime.now().toIso8601String(),
        'is_read': false,
      });
    } catch (e) {
      if (kDebugMode) {
        print('Error sending match notification: $e');
      }
    }
  }

  Future<void> passUser(String userId) async {
    _potentialMatches.removeWhere((user) => user.id == userId);
    notifyListeners();
  }

  Future<void> loadMatches(String userId) async {
    if (userId.isEmpty) {
      if (kDebugMode) {
        print('Error: userId is empty');
      }
      return;
    }

    _isLoading = true;
    notifyListeners();

    try {
      // First, get matches with user details
      final matchesResponse = await _supabase
          .from('matches')
          .select('''
            *,
            user1:users!matches_user1_id_fkey(*),
            user2:users!matches_user2_id_fkey(*)
          ''')
          .or('user1_id.eq.$userId,user2_id.eq.$userId')
          .eq('is_active', true)
          .order('created_at', ascending: false)
          .catchError((error) {
        if (kDebugMode) {
          print('Error loading matches: $error');
        }
        return [];
      });

      // Convert to Match objects with users array
      final matches = (matchesResponse as List).map((matchJson) {
        final user1 = AppUser.fromJson(matchJson['user1'] ?? {});
        final user2 = AppUser.fromJson(matchJson['user2'] ?? {});

        return Match(
          id: matchJson['id'] ?? '',
          users: [user1, user2],
          createdAt: matchJson['created_at'] != null
              ? DateTime.parse(matchJson['created_at'])
              : DateTime.now(),
          isActive: matchJson['is_active'] ?? true,
        );
      }).toList();

      // Now load last messages for each match
      for (final match in matches) {
        try {
          final lastMessageResponse = await _supabase
              .from('messages')
              .select()
              .eq('match_id', match.id)
              .order('created_at', ascending: false)
              .limit(1)
              .single()
              .catchError((_) => null);

          if (lastMessageResponse != null) {
            // Create a copy of the match with the last message
            final index = matches.indexOf(match);
            matches[index] = match.copyWith(
              lastMessage: Message.fromJson(lastMessageResponse),
            );
          }
        } catch (e) {
          if (kDebugMode) {
            print('Error loading last message for match ${match.id}: $e');
          }
        }
      }

      _matches = matches;
    } catch (e) {
      if (kDebugMode) {
        print('Error loading matches: $e');
      }
      _matches = [];
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> unmatch(String matchId) async {
    try {
      _isLoading = true;
      notifyListeners();

      await _supabase.from('matches').delete().eq('id', matchId);
      _matches.removeWhere((match) => match.id == matchId);
    } catch (e) {
      if (kDebugMode) {
        print('Error unmatching: $e');
      }
      rethrow;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> blockUser(String currentUserId, String blockUserId) async {
    try {
      await _supabase.from('blocked_users').insert({
        'user_id': currentUserId,
        'blocked_user_id': blockUserId,
        'created_at': DateTime.now().toIso8601String(),
      });

      // Remove from potential matches and matches
      _potentialMatches.removeWhere((user) => user.id == blockUserId);
      _matches.removeWhere((match) => match.users.any((user) => user.id == blockUserId));

      notifyListeners();
    } catch (e) {
      if (kDebugMode) {
        print('Error blocking user: $e');
      }
      rethrow;
    }
  }
}


// Chat Provider
// Enhanced Chat Provider
class ChatProvider extends ChangeNotifier {
  final SupabaseClient _supabase = Supabase.instance.client;
  List<Message> _messages = [];
  List<AppUser> _chatPartners = [];
  bool _isLoading = false;
  bool _isSending = false;

  List<Message> get messages => _messages;
  List<AppUser> get chatPartners => _chatPartners;
  bool get isLoading => _isLoading;
  bool get isSending => _isSending;

  // Real-time subscription for messages
  void subscribeToMessages(String currentUserId, String otherUserId) {
    _supabase
        .channel('messages')
        .onPostgresChanges(
      event: PostgresChangeEvent.all,
      schema: 'public',
      table: 'messages',
      callback: (payload) {
        if (payload.newRecord['sender_id'] == otherUserId ||
            payload.newRecord['receiver_id'] == otherUserId) {
          final message = Message.fromJson(payload.newRecord);
          _messages.add(message);
          notifyListeners();
        }
      },
    )
        .subscribe();
  }

  Future<void> sendMessage({
    required String senderId,
    required String receiverId,
    required String content,
    required MessageType type,
    String? mediaUrl,
    String? thumbnailUrl,
  }) async {
    try {
      _isSending = true;
      notifyListeners();

      final messageData = {
        'sender_id': senderId,
        'receiver_id': receiverId,
        'content': content,
        'message_type': type.toString().split('.').last,
        'created_at': DateTime.now().toIso8601String(),
        'is_read': false,
        'media_url': mediaUrl,
        'thumbnail_url': thumbnailUrl,
      };

      final response = await _supabase
          .from('messages')
          .insert(messageData)
          .select()
          .single();

      final message = Message.fromJson(response);
      _messages.add(message);

      // Update last message in match
      await _updateMatchLastMessage(senderId, receiverId, message.id);

      notifyListeners();
    } catch (e) {
      if (kDebugMode) {
        print('Error sending message: $e');
      }
      rethrow;
    } finally {
      _isSending = false;
      notifyListeners();
    }
  }

  Future<void> _updateMatchLastMessage(
      String user1Id,
      String user2Id,
      String messageId
      ) async {
    try {
      await _supabase
          .from('matches')
          .update({'last_message_id': messageId})
          .or('and(user1_id.eq.$user1Id,user2_id.eq.$user2Id),and(user1_id.eq.$user2Id,user2_id.eq.$user1Id)');
    } catch (e) {
      if (kDebugMode) {
        print('Error updating match last message: $e');
      }
    }
  }

  Future<void> loadMessages(String user1Id, String user2Id) async {
    _isLoading = true;
    notifyListeners();

    try {
      final response = await _supabase
          .from('messages')
          .select()
          .or('and(sender_id.eq.$user1Id,receiver_id.eq.$user2Id),and(sender_id.eq.$user2Id,receiver_id.eq.$user1Id)')
          .order('created_at', ascending: true);

      _messages = (response as List)
          .map((json) => Message.fromJson(json))
          .toList();

      // Mark messages as read
      await _markMessagesAsRead(user1Id, user2Id);
    } catch (e) {
      if (kDebugMode) {
        print('Error loading messages: $e');
      }
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> _markMessagesAsRead(String currentUserId, String otherUserId) async {
    try {
      await _supabase
          .from('messages')
          .update({'is_read': true})
          .eq('sender_id', otherUserId)
          .eq('receiver_id', currentUserId)
          .eq('is_read', false);

      // Update local messages
      for (var message in _messages) {
        if (message.senderId == otherUserId && !message.isRead) {
          message = message.copyWith(isRead: true);
        }
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error marking messages as read: $e');
      }
    }
  }

  Future<void> markAsRead(String messageId) async {
    try {
      await _supabase
          .from('messages')
          .update({'is_read': true})
          .eq('id', messageId);

      final messageIndex = _messages.indexWhere((msg) => msg.id == messageId);
      if (messageIndex != -1) {
        _messages[messageIndex] = _messages[messageIndex].copyWith(isRead: true);
        notifyListeners();
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error marking message as read: $e');
      }
    }
  }

  Future<void> loadChatPartners(String currentUserId) async {
    try {
      _isLoading = true;
      notifyListeners();

      final response = await _supabase
          .from('matches')
          .select('''
            *,
            user1:users!matches_user1_id_fkey(*),
            user2:users!matches_user2_id_fkey(*),
            last_message:messages!matches_last_message_id_fkey(*)
          ''')
          .or('user1_id.eq.$currentUserId,user2_id.eq.$currentUserId')
          .order('created_at', ascending: false);

      final partners = <AppUser>[];
      for (final match in response) {
        final user1 = AppUser.fromJson(match['user1']);
        final user2 = AppUser.fromJson(match['user2']);
        final partner = user1.id == currentUserId ? user2 : user1;
        partners.add(partner);
      }

      _chatPartners = partners;
    } catch (e) {
      if (kDebugMode) {
        print('Error loading chat partners: $e');
      }
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> deleteMessage(String messageId) async {
    try {
      await _supabase
          .from('messages')
          .delete()
          .eq('id', messageId);

      _messages.removeWhere((msg) => msg.id == messageId);
      notifyListeners();
    } catch (e) {
      if (kDebugMode) {
        print('Error deleting message: $e');
      }
      rethrow;
    }
  }

  void clearMessages() {
    _messages.clear();
    notifyListeners();
  }

  void disposeSubscription() {
    _supabase.removeAllChannels();
  }
}

// Discovery Provider
// Discovery Provider
// Enhanced Discovery Provider
// Discovery Provider
class DiscoveryProvider extends ChangeNotifier {
  final SupabaseClient _supabase = Supabase.instance.client;
  List<AppUser> _discoveredUsers = [];
  Map<String, dynamic> _filters = {
    'minAge': 18,
    'maxAge': 40,
    'gender': 'any',
    'location': '',
    'maxDistance': 50,
    'maritalStatus': 'any',
    'religion': 'any',
    'hasChildren': 'any',
    'wantsChildren': 'any',
    'smokingHabits': 'any',
    'drinkingHabits': 'any',
  };
  bool _isLoading = false;

  List<AppUser> get discoveredUsers => _discoveredUsers;
  Map<String, dynamic> get filters => _filters;
  bool get isLoading => _isLoading;
//_sortDiscoveredUsers(currentUserId);
  Future<void> discoverUsers(String currentUserId) async {
    _isLoading = true;
    notifyListeners();

    try {
      var query = _supabase
          .from('users')
          .select()
          .eq('id', currentUserId);

      if (_filters['gender'] != 'any') {
        query = query.eq('gender', _filters['gender']);
      }

      if (_filters['maritalStatus'] != 'any') {
        query = query.eq('marital_status', _filters['maritalStatus']);
      }

      if (_filters['religion'] != 'any') {
        query = query.eq('religion', _filters['religion']);
      }

      final response = await query.limit(50);

      _discoveredUsers = (response as List)
          .map((json) => AppUser.fromJson(json))
          .toList();
      _sortDiscoveredUsers(currentUserId);
    } catch (e) {
      if (kDebugMode) {
        print('Error discovering users: $e');
      }
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  void _sortDiscoveredUsers(String currentUserId) {
    _discoveredUsers.sort((a, b) {
      // Prioritize online users
      if (a.isOnline && !b.isOnline) return -1;
      if (!a.isOnline && b.isOnline) return 1;

      // Then by recent activity
      final aRecency = DateTime.now().difference(a.lastActive).inMinutes;
      final bRecency = DateTime.now().difference(b.lastActive).inMinutes;

      return aRecency.compareTo(bRecency);
    });
  }


  void updateFilters(Map<String, dynamic> newFilters) {
    _filters = {..._filters, ...newFilters};
    notifyListeners();
  }

  void resetFilters() {
    _filters = {
      'minAge': 18,
      'maxAge': 40,
      'gender': 'any',
      'location': '',
      'maxDistance': 50,
      'maritalStatus': 'any',
      'religion': 'any',
      'hasChildren': 'any',
      'wantsChildren': 'any',
      'smokingHabits': 'any',
      'drinkingHabits': 'any',
    };
    notifyListeners();
  }
  Future<void> saveSearchPreferences(String userId) async {
    try {
      await _supabase
          .from('user_preferences')
          .upsert({
        'user_id': userId,
        'search_filters': _filters,
        'updated_at': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      if (kDebugMode) {
        print('Error saving search preferences: $e');
      }
    }
  }

  Future<void> loadSearchPreferences(String userId) async {
    try {
      final response = await _supabase
          .from('user_preferences')
          .select()
          .eq('user_id', userId)
          .single()
          .catchError((_) => null);

      if (response != null) {
        _filters = Map<String, dynamic>.from(response['search_filters'] ?? {});
        notifyListeners();
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error loading search preferences: $e');
      }
    }
  }
  Future<bool> likeUser(String currentUserId, String likedUserId) async {
    try {
      // Validate inputs
      if (currentUserId.isEmpty || likedUserId.isEmpty) {
        throw Exception('Invalid user IDs');
      }

      // Record the like
      await _supabase
          .from('likes')
          .insert({
        'user_id': currentUserId,
        'liked_user_id': likedUserId,
        'created_at': DateTime.now().toIso8601String(),
      });

      // Check if it's a match (the other user has also liked current user)
      final mutualLike = await _supabase
          .from('likes')
          .select()
          .eq('user_id', likedUserId)
          .eq('liked_user_id', currentUserId)
          .maybeSingle()
          .catchError((error) {
        if (kDebugMode) {
          print('Error checking mutual like: $error');
        }
        return null;
      });

      bool isMatch = false;

      if (mutualLike != null) {
        // It's a match! Create a match record
        // Ensure consistent ordering of user IDs to avoid duplicates
        final user1Id = currentUserId.compareTo(likedUserId) < 0 ? currentUserId : likedUserId;
        final user2Id = currentUserId.compareTo(likedUserId) < 0 ? likedUserId : currentUserId;

        await _supabase
            .from('matches')
            .insert({
          'user1_id': user1Id,
          'user2_id': user2Id,
          'created_at': DateTime.now().toIso8601String(),
          'is_active': true,
        }).catchError((error) {
          if (kDebugMode) {
            print('Error creating match: $error');
          }
        });

        isMatch = true;
        _sendMatchNotification(currentUserId, likedUserId);
      }

      // Remove the liked user from discovered users
      _discoveredUsers.removeWhere((user) => user.id == likedUserId);
      notifyListeners();

      return isMatch;
    } catch (e) {
      if (kDebugMode) {
        print('Error liking user: $e');
      }
      rethrow;
    }
  }

  Future<void> passUser(String currentUserId, String passedUserId) async {
    try {
      // Record the pass
      await _supabase
          .from('passes')
          .insert({
        'user_id': currentUserId,
        'passed_user_id': passedUserId,
        'created_at': DateTime.now().toIso8601String(),
      });

      // Remove the passed user from discovered users
      _discoveredUsers.removeWhere((user) => user.id == passedUserId);
      notifyListeners();

    } catch (e) {
      if (kDebugMode) {
        print('Error passing user: $e');
      }
      rethrow;
    }
  }
  void _sendMatchNotification(String currentUserId, String matchedUserId) {
    // Implement push notification for match
    // You can use Firebase Cloud Messaging or another service
    if (kDebugMode) {
      print('Match created between $currentUserId and $matchedUserId');
    }
  }
}


// Match Model
// Match Model
class Match {
  final String id;
  final List<AppUser> users;
  final DateTime createdAt;
  final Message? lastMessage;
  final bool isActive;


  Match({
    required this.id,
    required this.users,
    required this.createdAt,
    this.lastMessage,
    this.isActive = true,
  });
  // Add copyWith method
  Match copyWith({
    String? id,
    List<AppUser>? users,
    DateTime? createdAt,
    Message? lastMessage,
    bool? isActive,
  }) {
    return Match(
      id: id ?? this.id,
      users: users ?? this.users,
      createdAt: createdAt ?? this.createdAt,
      lastMessage: lastMessage ?? this.lastMessage,
      isActive: isActive ?? this.isActive,
    );
  }
  factory Match.fromJson(Map<String, dynamic> json) {
    return Match(
      id: json['id'],
      users: List<AppUser>.from(json['users'].map((x) => AppUser.fromJson(x))),
      createdAt: DateTime.parse(json['created_at']),
      lastMessage: json['last_message'] != null
          ? Message.fromJson(json['last_message'])
          : null,
      isActive: json['is_active'] ?? true,
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'users': users.map((x) => x.toJson()).toList(),
    'created_at': createdAt.toIso8601String(),
    'last_message': lastMessage?.toJson(),
    'is_active': isActive,
  };
  // Helper method to get the other user in the match
  AppUser getOtherUser(String currentUserId) {
    return users.firstWhere(
          (user) => user.id != currentUserId,
      orElse: () => users.first, // Fallback if current user not found
    );
  }
}
// Message Model
enum MessageType {
  text,
  image,
  video,
  audio,
  system,
}

class Message {
  final String id;
  final String senderId;
  final String receiverId;
  final String content;
  final MessageType type;
  final DateTime timestamp;
  final bool isRead;
  final String? mediaUrl;
  final String? thumbnailUrl;
  final String? replyToId;

  Message({
    required this.id,
    required this.senderId,
    required this.receiverId,
    required this.content,
    required this.type,
    required this.timestamp,
    required this.isRead,
    this.mediaUrl,
    this.thumbnailUrl,
    this.replyToId,
  });

  factory Message.fromJson(Map<String, dynamic> json) {
    return Message(
      id: json['id'],
      senderId: json['sender_id'],
      receiverId: json['receiver_id'],
      content: json['content'],
      type: _parseMessageType(json['message_type'] ?? 'text'),
      timestamp: DateTime.parse(json['created_at']).toLocal(),
      isRead: json['is_read'] ?? false,
      mediaUrl: json['media_url'],
      thumbnailUrl: json['thumbnail_url'],
      replyToId: json['reply_to_id'],
    );
  }

  static MessageType _parseMessageType(String type) {
    switch (type) {
      case 'image': return MessageType.image;
      case 'video': return MessageType.video;
      case 'audio': return MessageType.audio;
      case 'system': return MessageType.system;
      default: return MessageType.text;
    }
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'sender_id': senderId,
    'receiver_id': receiverId,
    'content': content,
    'message_type': type.toString().split('.').last,
    'created_at': timestamp.toUtc().toIso8601String(),
    'is_read': isRead,
    'media_url': mediaUrl,
    'thumbnail_url': thumbnailUrl,
    'reply_to_id': replyToId,
  };

  Message copyWith({
    String? id,
    String? senderId,
    String? receiverId,
    String? content,
    MessageType? type,
    DateTime? timestamp,
    bool? isRead,
    String? mediaUrl,
    String? thumbnailUrl,
    String? replyToId,
  }) {
    return Message(
      id: id ?? this.id,
      senderId: senderId ?? this.senderId,
      receiverId: receiverId ?? this.receiverId,
      content: content ?? this.content,
      type: type ?? this.type,
      timestamp: timestamp ?? this.timestamp,
      isRead: isRead ?? this.isRead,
      mediaUrl: mediaUrl ?? this.mediaUrl,
      thumbnailUrl: thumbnailUrl ?? this.thumbnailUrl,
      replyToId: replyToId ?? this.replyToId,
    );
  }
}
// Discovery Screen
// Enhanced Discovery Screen
class DiscoveryScreen extends StatefulWidget {
  const DiscoveryScreen({super.key});

  @override
  State<DiscoveryScreen> createState() => _DiscoveryScreenState();
}

class _DiscoveryScreenState extends State<DiscoveryScreen> {
  int _currentIndex = 0;
  final PageController _pageController = PageController();

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  void _loadData() {
    final currentUserId = Supabase.instance.client.auth.currentUser?.id;
    if (currentUserId != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Provider.of<DiscoveryProvider>(context, listen: false).discoverUsers(currentUserId);
        Provider.of<MatchProvider>(context, listen: false).loadMatches(currentUserId);
      });
    }
  }
  void _handleLike(String currentUserId, String likedUserId) async {
    try {
      await Provider.of<DiscoveryProvider>(context, listen: false)
          .likeUser(currentUserId, likedUserId);

      // Show match dialog if it was a match
      final matchProvider = Provider.of<MatchProvider>(context, listen: false);
      await matchProvider.loadMatches(currentUserId); // Refresh matches

      // You can add a check here to show a special match dialog
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Liked user!'),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error liking user'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _handlePass(String currentUserId, String passedUserId) async {
    try {
      await Provider.of<DiscoveryProvider>(context, listen: false)
          .passUser(currentUserId, passedUserId);

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Passed user'),
          backgroundColor: Colors.orange,
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error passing user'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final discoveryProvider = Provider.of<DiscoveryProvider>(context);
    final currentUser = Supabase.instance.client.auth.currentUser;

    return Scaffold(
      backgroundColor: const Color(0xFF1A0F0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF231818),
        title: Text(
          AppLocalizations.of(context, 'discover'),
          style: const TextStyle(color: Color(0xFFFFD700), fontWeight: FontWeight.bold),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.filter_list, color: Color(0xFFFFD700)),
            onPressed: () => _showFilterDialog(context),
          ),
          IconButton(
            icon: const Icon(Icons.refresh, color: Color(0xFFFFD700)),
            onPressed: _loadData,
          ),
          IconButton(
            icon: const Icon(Icons.chat, color: Color(0xFFFFD700)),
            onPressed: () => _goToMatches(context),
          ),
        ],
      ),
      body: discoveryProvider.isLoading
          ? const Center(child: CircularProgressIndicator(color: Color(0xFFFFD700)))
          : _buildDiscoveryContent(discoveryProvider, currentUser?.id),
    );
  }

  Widget _buildDiscoveryContent(DiscoveryProvider discoveryProvider, String? currentUserId) {
    if (discoveryProvider.discoveredUsers.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.people_outline, size: 80, color: Colors.grey),
            const SizedBox(height: 16),
            Text(
              AppLocalizations.of(context, 'no_users_found'),
              style: const TextStyle(color: Colors.grey, fontSize: 18),
            ),
            const SizedBox(height: 8),
            Text(
              AppLocalizations.of(context, 'adjust_filters'),
              style: const TextStyle(color: Colors.grey),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _loadData,
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFFFFD700),
                foregroundColor: Colors.black,
              ),
              child: const Text('Refresh'),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => _goToMatches(context),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF4CAF50),
                foregroundColor: Colors.white,
              ),
              child: const Text('View Matches'),
            ),
          ],
        ),
      );
    }

    return Stack(
      children: [
        PageView.builder(
          controller: _pageController,
          itemCount: discoveryProvider.discoveredUsers.length,
          onPageChanged: (index) => setState(() => _currentIndex = index),
          itemBuilder: (context, index) {
            final user = discoveryProvider.discoveredUsers[index];
            return _UserCard(user: user);
          },
        ),
        Positioned(
          bottom: 20,
          left: 0,
          right: 0,
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _ActionButton(
                icon: Icons.close,
                color: Colors.red,
                onTap: () {
                  if (currentUserId != null) {
                    _handlePass(currentUserId, discoveryProvider.discoveredUsers[_currentIndex].id);
                    _nextCard();
                  }
                },
              ),
              _ActionButton(
                icon: Icons.favorite,
                color: const Color(0xFFFFD700),
                onTap: () {
                  if (currentUserId != null) {
                    _handleLike(currentUserId, discoveryProvider.discoveredUsers[_currentIndex].id);
                    _nextCard();
                  }
                },
              ),
              _ActionButton(
                icon: Icons.info_outline,
                color: Colors.blue,
                onTap: () => _showUserDetails(discoveryProvider.discoveredUsers[_currentIndex]),
              ),
            ],
          ),
        ),
        Positioned(
          top: 20,
          left: 0,
          right: 0,
          child: Center(
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.5),
                borderRadius: BorderRadius.circular(20),
              ),
              child: Text(
                '${_currentIndex + 1}/${discoveryProvider.discoveredUsers.length}',
                style: const TextStyle(color: Colors.white),
              ),
            ),
          ),
        ),
      ],
    );
  }

  void _goToMatches(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => MatchesScreen(),
      ),
    );
  }
  void _nextCard() {
    if (_pageController.hasClients) {
      _pageController.nextPage(
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
  }

  void _showUserDetails(AppUser user) {
    showModalBottomSheet(
      context: context,
      backgroundColor: const Color(0xFF231818),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Center(
                child: Container(
                  width: 60,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.grey,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Text(
                'About ${user.name}',
                style: const TextStyle(
                  color: Color(0xFFFFD700),
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              if (user.bio.isNotEmpty) ...[
                Text(
                  user.bio,
                  style: const TextStyle(color: Colors.white, fontSize: 16),
                ),
                const SizedBox(height: 16),
              ],
              _buildDetailRow(Icons.work, user.profession),
              _buildDetailRow(Icons.school, user.education),
              _buildDetailRow(Icons.location_on, user.location),
              _buildDetailRow(Icons.favorite, 'Relationship Goals: ${user.relationshipGoals}'),
              _buildDetailRow(Icons.fitness_center, 'Exercise: ${user.exerciseHabits}'),
              const SizedBox(height: 20),
            ],
          ),
        );
      },
    );
  }

  Widget _buildDetailRow(IconData icon, String text) {
    if (text.isEmpty) return const SizedBox();
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        children: [
          Icon(icon, color: const Color(0xFFFFD700), size: 20),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              text,
              style: const TextStyle(color: Colors.white, fontSize: 14),
            ),
          ),
        ],
      ),
    );
  }

  void _showFilterDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => FilterDialog(
        discoveryProvider: Provider.of<DiscoveryProvider>(context, listen: false),
        onFiltersApplied: _loadData,
      ),
    );
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }
}

class _UserCard extends StatelessWidget {
  final AppUser user;

  const _UserCard({required this.user});

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(20),
        image: user.photos.isNotEmpty
            ? DecorationImage(
          image: NetworkImage(user.photos.first),
          fit: BoxFit.cover,
        )
            : null,
        color: const Color(0xFF231818),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 10,
            spreadRadius: 2,
          ),
        ],
      ),
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(20),
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              Colors.transparent,
              Colors.black.withOpacity(0.1),
              Colors.black.withOpacity(0.8),
            ],
          ),
        ),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.end,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                    decoration: BoxDecoration(
                      color: const Color(0xFFFFD700),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      '${user.compatibilityScore.toStringAsFixed(1)}% Match',
                      style: const TextStyle(
                        color: Colors.black,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  if (user.isOnline)
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: Colors.green,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Text(
                        'Online',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                '${user.name}, ${user.age}',
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                  shadows: [
                    Shadow(
                      blurRadius: 10,
                      color: Colors.black,
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 8),
              if (user.profession.isNotEmpty) ...[
                Text(
                  user.profession,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    shadows: [
                      Shadow(
                        blurRadius: 5,
                        color: Colors.black,
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 4),
              ],
              Text(
                user.location,
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 14,
                  shadows: [
                    Shadow(
                      blurRadius: 5,
                      color: Colors.black,
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 8),
              if (user.bio.isNotEmpty)
                Text(
                  user.bio,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 14,
                    shadows: [
                      Shadow(
                        blurRadius: 5,
                        color: Colors.black,
                      ),
                    ],
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                runSpacing: 4,
                children: user.interests.take(3).map((interest) {
                  return Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: const Color(0xFFFFD700).withOpacity(0.2),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(color: const Color(0xFFFFD700).withOpacity(0.5)),
                    ),
                    child: Text(
                      interest,
                      style: const TextStyle(
                        color: Color(0xFFFFD700),
                        fontSize: 10,
                      ),
                    ),
                  );
                }).toList(),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


class _ActionButton extends StatelessWidget {
  final IconData icon;
  final Color color;
  final VoidCallback onTap;

  const _ActionButton({required this.icon, required this.color, required this.onTap});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 60,
        height: 60,
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          boxShadow: [
            BoxShadow(
              color: color.withOpacity(0.5),
              blurRadius: 10,
              spreadRadius: 2,
            ),
          ],
        ),
        child: Icon(icon, color: Colors.white, size: 30),
      ),
    );
  }
}

// Enhanced Filter Dialog
class FilterDialog extends StatefulWidget {
  final DiscoveryProvider discoveryProvider;
  final VoidCallback? onFiltersApplied;

  const FilterDialog({super.key, required this.discoveryProvider, this.onFiltersApplied});

  @override
  State<FilterDialog> createState() => _FilterDialogState();
}

class _FilterDialogState extends State<FilterDialog> {
  late Map<String, dynamic> _tempFilters;

  @override
  void initState() {
    super.initState();
    _tempFilters = Map.from(widget.discoveryProvider.filters);
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      backgroundColor: const Color(0xFF231818),
      title: Text(
        AppLocalizations.of(context, 'filters'),
        style: const TextStyle(color: Color(0xFFFFD700)),
      ),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildRangeSlider(),
            const SizedBox(height: 16),
            _buildDropdown('gender', ['any', 'male', 'female'], 'Gender'),
            const SizedBox(height: 16),
            _buildDropdown('maritalStatus', ['any', 'single', 'married', 'divorced', 'widowed'], 'Marital Status'),
            const SizedBox(height: 16),
            _buildDropdown('religion', ['any', 'muslim', 'christian', 'jewish', 'hindu', 'buddhist', 'other'], 'Religion'),
            const SizedBox(height: 16),
            _buildDropdown('hasChildren', ['any', 'yes', 'no'], 'Has Children'),
            const SizedBox(height: 16),
            _buildDropdown('wantsChildren', ['any', 'yes', 'no'], 'Wants Children'),
            const SizedBox(height: 16),
            _buildDropdown('smokingHabits', ['any', 'Never', 'Occasionally', 'Regularly'], 'Smoking'),
            const SizedBox(height: 16),
            _buildDropdown('drinkingHabits', ['any', 'Never', 'Occasionally', 'Regularly'], 'Drinking'),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () {
            widget.discoveryProvider.resetFilters();
            Navigator.pop(context);
            widget.onFiltersApplied?.call();
          },
          child: const Text('Reset', style: TextStyle(color: Colors.grey)),
        ),
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text(AppLocalizations.of(context, 'cancel'), style: const TextStyle(color: Colors.grey)),
        ),
        ElevatedButton(
          onPressed: () {
            widget.discoveryProvider.updateFilters(_tempFilters);
            Navigator.pop(context);
            widget.onFiltersApplied?.call();
          },
          style: ElevatedButton.styleFrom(backgroundColor: const Color(0xFFFFD700)),
          child: Text(AppLocalizations.of(context, 'apply'), style: const TextStyle(color: Colors.black)),
        ),
      ],
    );
  }

  Widget _buildRangeSlider() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Age Range: ${_tempFilters['minAge']} - ${_tempFilters['maxAge']}',
          style: const TextStyle(color: Colors.white),
        ),
        RangeSlider(
          values: RangeValues(
            _tempFilters['minAge'].toDouble(),
            _tempFilters['maxAge'].toDouble(),
          ),
          min: 18,
          max: 80,
          divisions: 62,
          labels: RangeLabels(
            _tempFilters['minAge'].toString(),
            _tempFilters['maxAge'].toString(),
          ),
          onChanged: (values) {
            setState(() {
              _tempFilters['minAge'] = values.start.round();
              _tempFilters['maxAge'] = values.end.round();
            });
          },
          activeColor: const Color(0xFFFFD700),
          inactiveColor: Colors.grey,
        ),
      ],
    );
  }

  Widget _buildDropdown(String key, List<String> options, String label) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(color: Colors.white, fontSize: 14),
        ),
        const SizedBox(height: 4),
        DropdownButtonFormField<String>(
          value: _tempFilters[key],
          dropdownColor: const Color(0xFF231818),
          style: const TextStyle(color: Colors.white),
          decoration: InputDecoration(
            contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
            ),
          ),
          items: options.map((option) {
            return DropdownMenuItem(
              value: option,
              child: Text(option),
            );
          }).toList(),
          onChanged: (value) {
            setState(() {
              _tempFilters[key] = value;
            });
          },
        ),
      ],
    );
  }
}


// Enhanced Main Navigation Screen
class MainNavigationScreen extends StatefulWidget {
  const MainNavigationScreen({super.key});

  @override
  State<MainNavigationScreen> createState() => _MainNavigationScreenState();
}

class _MainNavigationScreenState extends State<MainNavigationScreen> {
  int _selectedIndex = 0;

  static final List<Widget> _widgetOptions = [
    const DiscoveryScreen(),
    const MatchesScreen(),
    const ChatListScreen(),
    const ProfileScreen(),
  ];

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.transparent,
      body: Stack(
        children: [
          Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [Color(0xFF1A0F0F), Color(0xFF2A1A1A), Color(0xFF1A0F0F)],
              ),
            ),
          ),
          _widgetOptions[_selectedIndex],
        ],
      ),
      bottomNavigationBar: _buildBottomNavigationBar(),
    );
  }

  Widget _buildBottomNavigationBar() {
    final navItems = [
      {'icon': Icons.explore_rounded, 'label': AppLocalizations.of(context, 'discover')},
      {'icon': Icons.favorite_rounded, 'label': AppLocalizations.of(context, 'matches')},
      {'icon': Icons.chat_rounded, 'label': AppLocalizations.of(context, 'messages')},
      {'icon': Icons.person_rounded, 'label': AppLocalizations.of(context, 'profile')},
    ];

    return Container(
      margin: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: const Color(0xFF1A0F0F).withOpacity(0.92),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 10,
            spreadRadius: 2,
          ),
        ],
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 8),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: List.generate(navItems.length, (i) {
            final selected = _selectedIndex == i;
            return GestureDetector(
              onTap: () => _onItemTapped(i),
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 300),
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                decoration: BoxDecoration(
                  color: selected ? const Color(0xFFFFD700).withOpacity(0.2) : Colors.transparent,
                  borderRadius: BorderRadius.circular(12),
                  border: selected ? Border.all(color: const Color(0xFFFFD700).withOpacity(0.5)) : null,
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      navItems[i]['icon'] as IconData,
                      color: selected ? const Color(0xFFFFD700) : const Color(0xFFFFD700).withOpacity(0.55),
                      size: selected ? 24 : 20,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      navItems[i]['label'] as String,
                      style: TextStyle(
                        color: selected ? const Color(0xFFFFD700) : const Color(0xFFFFD700).withOpacity(0.55),
                        fontWeight: selected ? FontWeight.bold : FontWeight.w500,
                        fontSize: selected ? 12 : 11,
                      ),
                    ),
                  ],
                ),
              ),
            );
          }),
        ),
      ),
    );
  }
}

// Matches Screen
// Enhanced Matches Screen
class MatchesScreen extends StatefulWidget {
  const MatchesScreen({super.key});

  @override
  State<MatchesScreen> createState() => _MatchesScreenState();
}

class _MatchesScreenState extends State<MatchesScreen> {
  @override
  void initState() {
    super.initState();
    _loadMatches();
  }

  void _loadMatches() {
    final currentUserId = Supabase.instance.client.auth.currentUser?.id;
    if (currentUserId != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Provider.of<MatchProvider>(context, listen: false).loadMatches(currentUserId);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final matchProvider = Provider.of<MatchProvider>(context);

    return Scaffold(
      backgroundColor: const Color(0xFF1A0F0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF231818),
        title: Text(
          AppLocalizations.of(context, 'matches'),
          style: const TextStyle(color: Color(0xFFFFD700), fontWeight: FontWeight.bold),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh, color: Color(0xFFFFD700)),
            onPressed: _loadMatches,
          ),
        ],
      ),
      body: matchProvider.isLoading
          ? const Center(child: CircularProgressIndicator(color: Color(0xFFFFD700)))
          : _buildMatchesContent(matchProvider),
    );
  }

  Widget _buildMatchesContent(MatchProvider matchProvider) {
    if (matchProvider.matches.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.favorite_border, size: 80, color: Colors.grey),
            const SizedBox(height: 16),
            Text(
              AppLocalizations.of(context, 'no_matches_yet'),
              style: const TextStyle(color: Colors.grey, fontSize: 18),
            ),
            const SizedBox(height: 8),
            Text(
              AppLocalizations.of(context, 'start_discovering'),
              style: const TextStyle(color: Colors.grey),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: () {
                // Navigate to discovery screen
                if (mounted) {
                  final navigationState = Navigator.of(context);
                  if (navigationState.canPop()) {
                    navigationState.pop();
                  }
                }
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFFFFD700),
                foregroundColor: Colors.black,
              ),
              child: const Text('Start Discovering'),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: () async {
        final currentUserId = Supabase.instance.client.auth.currentUser?.id;
        if (currentUserId != null) {
          await matchProvider.loadMatches(currentUserId);
        }
      },
      backgroundColor: const Color(0xFF1A0F0F),
      color: const Color(0xFFFFD700),
      child: ListView.builder(
        padding: const EdgeInsets.all(16),
        itemCount: matchProvider.matches.length,
        itemBuilder: (context, index) {
          final match = matchProvider.matches[index];
          final otherUser = match.users.first;

          return _MatchCard(
            match: match,
            otherUser: otherUser,
            onTap: () => _openChat(context, otherUser),
            onUnmatch: () => _showUnmatchDialog(matchProvider, match.id),
          );
        },
      ),
    );
  }

  void _openChat(BuildContext context, AppUser otherUser) {
    // Navigate to chat screen
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => IndividualChatScreen(matchUserId: otherUser.id),
      ),
    );
  }

  void _showUnmatchDialog(MatchProvider matchProvider, String matchId) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF231818),
        title: Text(
          AppLocalizations.of(context, 'unmatch'),
          style: const TextStyle(color: Color(0xFFFFD700)),
        ),
        content: Text(
          AppLocalizations.of(context, 'unmatch_confirm'),
          style: const TextStyle(color: Colors.white),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(
              AppLocalizations.of(context, 'cancel'),
              style: const TextStyle(color: Colors.grey),
            ),
          ),
          TextButton(
            onPressed: () {
              matchProvider.unmatch(matchId);
              Navigator.pop(context);
            },
            child: const Text(
              'Unmatch',
              style: TextStyle(color: Colors.red),
            ),
          ),
        ],
      ),
    );
  }
}


class _MatchCard extends StatelessWidget {
  final Match match;
  final AppUser otherUser;
  final VoidCallback onTap;
  final VoidCallback onUnmatch;

  const _MatchCard({
    required this.match,
    required this.otherUser,
    required this.onTap,
    required this.onUnmatch,
  });

  @override
  Widget build(BuildContext context) {
    final lastMessage = match.lastMessage;
    final timeAgo = _getTimeAgo(match.createdAt);

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      decoration: BoxDecoration(
        color: const Color(0xFF231818),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: const Color(0xFFFFD700).withOpacity(0.2)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 8,
            spreadRadius: 2,
          ),
        ],
      ),
      child: ListTile(
        contentPadding: const EdgeInsets.all(16),
        leading: Stack(
          children: [
            CircleAvatar(
              radius: 30,
              backgroundImage: otherUser.photos.isNotEmpty
                  ? NetworkImage(otherUser.photos.first)
                  : const AssetImage('assets/default_avatar.png') as ImageProvider,
              backgroundColor: Colors.grey[800],
            ),
            if (otherUser.isOnline)
              Positioned(
                bottom: 0,
                right: 0,
                child: Container(
                  width: 14,
                  height: 14,
                  decoration: const BoxDecoration(
                    color: Colors.green,
                    shape: BoxShape.circle,
                    border: Border.fromBorderSide(BorderSide(color: Colors.white, width: 2)),
                  ),
                ),
              ),
          ],
        ),
        title: Row(
          children: [
            Text(
              otherUser.name,
              style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 18),
            ),
            const SizedBox(width: 8),
            if (otherUser.isVerified)
              const Icon(Icons.verified, color: Color(0xFFFFD700), size: 16),
          ],
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '${otherUser.age} • ${otherUser.location}',
              style: const TextStyle(color: Colors.white70),
            ),
            const SizedBox(height: 4),
            if (lastMessage != null)
              Text(
                lastMessage.content,
                style: const TextStyle(color: Colors.white54),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              )
            else
              const Text(
                'Say hello!',
                style: TextStyle(color: Colors.white54, fontStyle: FontStyle.italic),
              ),
          ],
        ),
        trailing: Column(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Text(
              timeAgo,
              style: TextStyle(color: Colors.white.withOpacity(0.6), fontSize: 12),
            ),
            if (lastMessage != null && !lastMessage.isRead)
              Container(
                width: 20,
                height: 20,
                decoration: const BoxDecoration(
                  color: Color(0xFFFFD700),
                  shape: BoxShape.circle,
                ),
                child: const Center(
                  child: Text(
                    '1',
                    style: TextStyle(color: Colors.black, fontSize: 12, fontWeight: FontWeight.bold),
                  ),
                ),
              ),
          ],
        ),
        onTap: onTap,
      ),
    );
  }

  String _getTimeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 1) return 'Now';
    if (difference.inMinutes < 60) return '${difference.inMinutes}m';
    if (difference.inHours < 24) return '${difference.inHours}h';
    if (difference.inDays < 7) return '${difference.inDays}d';
    if (difference.inDays < 30) return '${(difference.inDays / 7).floor()}w';
    return '${(difference.inDays / 30).floor()}mo';
  }
}


// Chat List Screen
// Enhanced Chat List Screen
class ChatListScreen extends StatefulWidget {
  const ChatListScreen({super.key});

  @override
  State<ChatListScreen> createState() => _ChatListScreenState();
}

class _ChatListScreenState extends State<ChatListScreen> {
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadChatPartners();
  }

  void _loadChatPartners() {
    final currentUserId = Supabase.instance.client.auth.currentUser?.id;
    if (currentUserId != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Provider.of<ChatProvider>(context, listen: false).loadChatPartners(currentUserId);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final chatProvider = Provider.of<ChatProvider>(context);

    return Scaffold(
      backgroundColor: const Color(0xFF1A0F0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF231818),
        title: Text(
          AppLocalizations.of(context, 'messages'),
          style: const TextStyle(color: Color(0xFFFFD700), fontWeight: FontWeight.bold),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.search, color: Color(0xFFFFD700)),
            onPressed: () => _showSearchDialog(context),
          ),
        ],
      ),
      body: chatProvider.isLoading
          ? const Center(child: CircularProgressIndicator(color: Color(0xFFFFD700)))
          : _buildChatList(chatProvider),
    );
  }

  Widget _buildChatList(ChatProvider chatProvider) {
    if (chatProvider.chatPartners.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.chat_bubble_outline, size: 80, color: Colors.grey),
            const SizedBox(height: 16),
            Text(
              AppLocalizations.of(context, 'no_messages_yet'),
              style: const TextStyle(color: Colors.grey, fontSize: 18),
            ),
            const SizedBox(height: 8),
            Text(
              AppLocalizations.of(context, 'start_conversation'),
              style: const TextStyle(color: Colors.grey),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: () async {
        final currentUserId = Supabase.instance.client.auth.currentUser?.id;
        if (currentUserId != null) {
          await chatProvider.loadChatPartners(currentUserId);
        }
      },
      backgroundColor: const Color(0xFF1A0F0F),
      color: const Color(0xFFFFD700),
      child: ListView.builder(
        padding: const EdgeInsets.all(16),
        itemCount: chatProvider.chatPartners.length,
        itemBuilder: (context, index) {
          final partner = chatProvider.chatPartners[index];
          return _ChatPartnerCard(
            partner: partner,
            onTap: () => _openChat(context, partner),
          );
        },
      ),
    );
  }

  void _openChat(BuildContext context, AppUser partner) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => IndividualChatScreen(matchUserId: partner.id),
      ),
    );
  }

  void _showSearchDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF231818),
        title: Text(
          AppLocalizations.of(context, 'search_messages'),
          style: const TextStyle(color: Color(0xFFFFD700)),
        ),
        content: TextField(
          controller: _searchController,
          style: const TextStyle(color: Colors.white),
          decoration: InputDecoration(
            hintText: AppLocalizations.of(context, 'search_messages'),
            hintStyle: const TextStyle(color: Colors.white54),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: const Color(0xFFFFD700).withOpacity(0.5)),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: const BorderSide(color: Color(0xFFFFD700)),
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              _searchController.clear();
            },
            child: Text(
              AppLocalizations.of(context, 'cancel'),
              style: const TextStyle(color: Colors.grey),
            ),
          ),
          ElevatedButton(
            onPressed: () {
              // Implement search functionality
              Navigator.pop(context);
              _searchController.clear();
            },
            style: ElevatedButton.styleFrom(backgroundColor: const Color(0xFFFFD700)),
            child: Text(
              AppLocalizations.of(context, 'search'),
              style: const TextStyle(color: Colors.black),
            ),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }
}

//ChatPartnerCard
class _ChatPartnerCard extends StatelessWidget {
  final AppUser partner;
  final VoidCallback onTap;

  const _ChatPartnerCard({required this.partner, required this.onTap});

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      decoration: BoxDecoration(
        color: const Color(0xFF231818),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: const Color(0xFFFFD700).withOpacity(0.2)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 8,
            spreadRadius: 2,
          ),
        ],
      ),
      child: ListTile(
        contentPadding: const EdgeInsets.all(16),
        leading: Stack(
          children: [
            CircleAvatar(
              radius: 25,
              backgroundImage: partner.photos.isNotEmpty
                  ? NetworkImage(partner.photos.first)
                  : const AssetImage('assets/default_avatar.png') as ImageProvider,
              backgroundColor: Colors.grey[800],
            ),
            if (partner.isOnline)
              Positioned(
                bottom: 0,
                right: 0,
                child: Container(
                  width: 12,
                  height: 12,
                  decoration: const BoxDecoration(
                    color: Colors.green,
                    shape: BoxShape.circle,
                    border: Border.fromBorderSide(BorderSide(color: Colors.white, width: 1.5)),
                  ),
                ),
              ),
          ],
        ),
        title: Text(
          partner.name,
          style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
        ),
        subtitle: Text(
          partner.bio.isNotEmpty ? partner.bio : 'Tap to start chatting',
          style: const TextStyle(color: Colors.white70),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        trailing: Column(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Text(
              '2m ago',
              style: TextStyle(color: Colors.white.withOpacity(0.6), fontSize: 12),
            ),
            Container(
              width: 20,
              height: 20,
              decoration: const BoxDecoration(
                color: Color(0xFFFFD700),
                shape: BoxShape.circle,
              ),
              child: const Center(
                child: Text(
                  '3',
                  style: TextStyle(color: Colors.black, fontSize: 12, fontWeight: FontWeight.bold),
                ),
              ),
            ),
          ],
        ),
        onTap: onTap,
      ),
    );
  }
}

// Individual Chat Screen
// Enhanced Individual Chat Screen
class IndividualChatScreen extends StatefulWidget {
  final String matchUserId;

  const IndividualChatScreen({super.key, required this.matchUserId});

  @override
  State<IndividualChatScreen> createState() => _IndividualChatScreenState();
}

class _IndividualChatScreenState extends State<IndividualChatScreen> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  late ChatProvider _chatProvider;
  late AppUser _partner;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _chatProvider = Provider.of<ChatProvider>(context, listen: false);
    _loadChatData();
  }

  void _loadChatData() async {
    try {
      final currentUserId = Supabase.instance.client.auth.currentUser?.id;
      if (currentUserId != null) {
        final partnerResponse = await Supabase.instance.client
            .from('users')
            .select()
            .eq('id', widget.matchUserId)
            .single();

        setState(() {
          _partner = AppUser.fromJson(partnerResponse);
          _isLoading = false;
        });

        _chatProvider.loadMessages(currentUserId, widget.matchUserId);
        _chatProvider.subscribeToMessages(currentUserId, widget.matchUserId);
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error loading chat data: $e');
      }
      setState(() {
        _isLoading = false;
      });
    }
  }

  void _sendMessage() {
    final currentUserId = Supabase.instance.client.auth.currentUser?.id;
    if (currentUserId != null && _messageController.text.trim().isNotEmpty) {
      _chatProvider.sendMessage(
        senderId: currentUserId,
        receiverId: widget.matchUserId,
        content: _messageController.text.trim(),
        type: MessageType.text,
      );
      _messageController.clear();
      _scrollToBottom();
    }
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients) {
        _scrollController.animateTo(
          _scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    });
  }

  void _showMediaOptions() {
    showModalBottomSheet(
      context: context,
      backgroundColor: const Color(0xFF231818),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return SafeArea(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                ListTile(
                  leading: const Icon(Icons.photo, color: Color(0xFFFFD700)),
                  title: const Text('Photo Library', style: TextStyle(color: Colors.white)),
                  onTap: () {
                    Navigator.pop(context);
                    // Implement photo selection
                  },
                ),
                ListTile(
                  leading: const Icon(Icons.camera_alt, color: Color(0xFFFFD700)),
                  title: const Text('Take Photo', style: TextStyle(color: Colors.white)),
                  onTap: () {
                    Navigator.pop(context);
                    // Implement camera
                  },
                ),
                ListTile(
                  leading: const Icon(Icons.videocam, color: Color(0xFFFFD700)),
                  title: const Text('Video', style: TextStyle(color: Colors.white)),
                  onTap: () {
                    Navigator.pop(context);
                    // Implement video
                  },
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Scaffold(
        backgroundColor: Color(0xFF1A0F0F),
        body: Center(child: CircularProgressIndicator(color: Color(0xFFFFD700))),
      );
    }

    return ChangeNotifierProvider.value(
      value: _chatProvider,
      child: Scaffold(
        backgroundColor: const Color(0xFF1A0F0F),
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Color(0xFF1A0F0F), Color(0xFF231616), Color(0xFF1A0F0F)],
              stops: [0.0, 0.5, 1.0],
            ),
          ),
          child: SafeArea(
            child: Column(
              children: [
                _buildHeader(),
                Expanded(child: _buildMessagesList()),
                _buildMessageInput(),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: const Color(0xFF231616).withOpacity(0.8),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
        border: Border(
          bottom: BorderSide(
            color: const Color(0xFFFFD700).withOpacity(0.2),
            width: 1,
          ),
        ),
      ),
      child: Row(
        children: [
          IconButton(
            icon: Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.white.withOpacity(0.1),
                border: Border.all(color: Colors.white.withOpacity(0.3), width: 1),
              ),
              child: const Icon(Icons.arrow_back_ios, color: Colors.white, size: 20),
            ),
            onPressed: () => Navigator.of(context).pop(),
          ),
          const SizedBox(width: 12),
          GestureDetector(
            onTap: _showPartnerProfile,
            child: Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: const LinearGradient(colors: [Color(0xFFFFD700), Color(0xFFFFA500)]),
                boxShadow: [
                  BoxShadow(
                    color: const Color(0xFFFFD700).withOpacity(0.3),
                    blurRadius: 8,
                    spreadRadius: 1,
                  ),
                ],
              ),
              child: _partner.photos.isNotEmpty
                  ? CircleAvatar(backgroundImage: NetworkImage(_partner.photos.first))
                  : Center(
                child: Text(
                  _partner.name.isNotEmpty ? _partner.name[0].toUpperCase() : 'U',
                  style: const TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold),
                ),
              ),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  _partner.name,
                  style: const TextStyle(color: Colors.white, fontSize: 16, fontWeight: FontWeight.w600),
                ),
                Text(
                  _partner.isOnline ? 'Online' : 'Last seen ${_getLastSeen(_partner.lastActive)}',
                  style: TextStyle(color: Colors.white.withOpacity(0.7), fontSize: 12),
                ),
              ],
            ),
          ),
          IconButton(
            icon: const Icon(Icons.videocam, color: Color(0xFFFFD700)),
            onPressed: _startVideoCall,
          ),
          IconButton(
            icon: const Icon(Icons.phone, color: Color(0xFFFFD700)),
            onPressed: _startVoiceCall,
          ),
          PopupMenuButton(
            icon: const Icon(Icons.more_vert, color: Color(0xFFFFD700)),
            color: const Color(0xFF231818),
            itemBuilder: (context) => [
              const PopupMenuItem(
                value: 'profile',
                child: Row(
                  children: [
                    Icon(Icons.person, color: Color(0xFFFFD700)),
                    SizedBox(width: 8),
                    Text('View Profile', style: TextStyle(color: Colors.white)),
                  ],
                ),
              ),
              const PopupMenuItem(
                value: 'block',
                child: Row(
                  children: [
                    Icon(Icons.block, color: Colors.red),
                    SizedBox(width: 8),
                    Text('Block User', style: TextStyle(color: Colors.white)),
                  ],
                ),
              ),
            ],
            onSelected: (value) {
              if (value == 'profile') {
                _showPartnerProfile();
              } else if (value == 'block') {
                _showBlockDialog();
              }
            },
          ),
        ],
      ),
    );
  }

  Widget _buildMessagesList() {
    return Consumer<ChatProvider>(
      builder: (context, chatProvider, child) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (chatProvider.messages.isNotEmpty && _scrollController.hasClients) {
            _scrollToBottom();
          }
        });

        if (chatProvider.isLoading) {
          return const Center(child: CircularProgressIndicator(color: Color(0xFFFFD700)));
        }

        if (chatProvider.messages.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.chat_bubble_outline, color: Colors.white.withOpacity(0.5), size: 64),
                const SizedBox(height: 16),
                Text(
                  AppLocalizations.of(context, 'no_messages_yet'),
                  style: TextStyle(color: Colors.white.withOpacity(0.7), fontSize: 16),
                ),
                const SizedBox(height: 8),
                Text(
                  AppLocalizations.of(context, 'start_conversation'),
                  style: TextStyle(color: Colors.white.withOpacity(0.5), fontSize: 14),
                ),
              ],
            ),
          );
        }

        return ListView.builder(
          controller: _scrollController,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          itemCount: chatProvider.messages.length,
          itemBuilder: (context, index) {
            final message = chatProvider.messages[index];
            final currentUserId = Supabase.instance.client.auth.currentUser?.id;
            final isMyMessage = message.senderId == currentUserId;

            return _buildMessageBubble(message, isMyMessage);
          },
        );
      },
    );
  }

  Widget _buildMessageBubble(Message message, bool isMyMessage) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: isMyMessage ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (!isMyMessage) ...[
            GestureDetector(
              onTap: _showPartnerProfile,
              child: Container(
                width: 32,
                height: 32,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  gradient: const LinearGradient(colors: [Color(0xFFFFD700), Color(0xFFFFA500)]),
                ),
                child: _partner.photos.isNotEmpty
                    ? CircleAvatar(backgroundImage: NetworkImage(_partner.photos.first))
                    : Center(
                  child: Text(
                    _partner.name.isNotEmpty ? _partner.name[0].toUpperCase() : 'U',
                    style: const TextStyle(color: Colors.white, fontSize: 12, fontWeight: FontWeight.bold),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 8),
          ],
          Flexible(
            child: Container(
              constraints: BoxConstraints(maxWidth: MediaQuery.of(context).size.width * 0.75),
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              decoration: BoxDecoration(
                color: isMyMessage
                    ? const Color(0xFFFFD700).withOpacity(0.2)
                    : const Color(0xFF231616).withOpacity(0.8),
                borderRadius: BorderRadius.circular(20).copyWith(
                  bottomLeft: isMyMessage ? const Radius.circular(20) : const Radius.circular(4),
                  bottomRight: isMyMessage ? const Radius.circular(4) : const Radius.circular(20),
                ),
                border: Border.all(
                  color: isMyMessage
                      ? const Color(0xFFFFD700).withOpacity(0.3)
                      : Colors.white.withOpacity(0.1),
                  width: 1,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (message.type != MessageType.text) ...[
                    Icon(
                      _getMessageTypeIcon(message.type),
                      color: const Color(0xFFFFD700),
                      size: 20,
                    ),
                    const SizedBox(height: 4),
                  ],
                  Text(
                    message.content,
                    style: TextStyle(
                      color: isMyMessage ? Colors.white : Colors.white.withOpacity(0.9),
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        _formatTime(message.timestamp),
                        style: TextStyle(
                          color: Colors.white.withOpacity(0.5),
                          fontSize: 12,
                        ),
                      ),
                      if (isMyMessage) ...[
                        const SizedBox(width: 4),
                        Icon(
                          message.isRead ? Icons.done_all : Icons.done,
                          size: 14,
                          color: message.isRead ? const Color(0xFFFFD700) : Colors.white.withOpacity(0.5),
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),
          if (isMyMessage) ...[
            const SizedBox(width: 8),
            Container(
              width: 32,
              height: 32,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: const LinearGradient(colors: [Color(0xFF4CAF50), Color(0xFF45A049)]),
              ),
              child: const Center(
                child: Icon(Icons.person, color: Colors.white, size: 16),
              ),
            ),
          ],
        ],
      ),
    );
  }

  IconData _getMessageTypeIcon(MessageType type) {
    switch (type) {
      case MessageType.image:
        return Icons.photo;
      case MessageType.video:
        return Icons.videocam;
      case MessageType.audio:
        return Icons.mic;
      case MessageType.system:
        return Icons.info;
      default:
        return Icons.text_snippet;
    }
  }

  Widget _buildMessageInput() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFF231616).withOpacity(0.8),
        border: Border(
          top: BorderSide(color: Colors.white.withOpacity(0.1), width: 1),
        ),
      ),
      child: Row(
        children: [
          IconButton(
            icon: const Icon(Icons.add, color: Color(0xFFFFD700)),
            onPressed: _showMediaOptions,
          ),
          Expanded(
            child: Container(
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.1),
                borderRadius: BorderRadius.circular(25),
                border: Border.all(color: Colors.white.withOpacity(0.2), width: 1),
              ),
              child: Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: _messageController,
                      style: const TextStyle(color: Colors.white),
                      decoration: InputDecoration(
                        hintText: AppLocalizations.of(context, 'type_message'),
                        hintStyle: const TextStyle(color: Colors.white54),
                        border: InputBorder.none,
                        contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                      ),
                      onSubmitted: (_) => _sendMessage(),
                      maxLines: null,
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.emoji_emotions, color: Color(0xFFFFD700)),
                    onPressed: () {
                      // Implement emoji picker
                    },
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(width: 12),
          GestureDetector(
            onTap: _sendMessage,
            child: Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                gradient: const LinearGradient(colors: [Color(0xFFFFD700), Color(0xFFFFA500)]),
                shape: BoxShape.circle,
                boxShadow: [
                  BoxShadow(
                    color: const Color(0xFFFFD700).withOpacity(0.3),
                    blurRadius: 8,
                    spreadRadius: 1,
                  ),
                ],
              ),
              child: const Icon(Icons.send, color: Colors.white, size: 20),
            ),
          ),
        ],
      ),
    );
  }

  String _formatTime(DateTime time) {
    final localTime = time.toLocal();
    final now = DateTime.now();
    final difference = now.difference(localTime);

    if (localTime.year == now.year && localTime.month == now.month && localTime.day == now.day) {
      final hour = localTime.hour.toString().padLeft(2, '0');
      final minute = localTime.minute.toString().padLeft(2, '0');
      return '$hour:$minute';
    }

    if (difference.inDays == 1) {
      final hour = localTime.hour.toString().padLeft(2, '0');
      final minute = localTime.minute.toString().padLeft(2, '0');
      return 'Yesterday $hour:$minute';
    }

    final day = localTime.day.toString().padLeft(2, '0');
    final month = localTime.month.toString().padLeft(2, '0');
    final hour = localTime.hour.toString().padLeft(2, '0');
    final minute = localTime.minute.toString().padLeft(2, '0');
    return '$day/$month $hour:$minute';
  }

  String _getLastSeen(DateTime lastActive) {
    final now = DateTime.now();
    final difference = now.difference(lastActive);

    if (difference.inMinutes < 1) return 'just now';
    if (difference.inMinutes < 60) return '${difference.inMinutes}m ago';
    if (difference.inHours < 24) return '${difference.inHours}h ago';
    if (difference.inDays < 7) return '${difference.inDays}d ago';
    return '${(difference.inDays / 7).floor()}w ago';
  }

  void _showPartnerProfile() {
    showModalBottomSheet(
      context: context,
      backgroundColor: const Color(0xFF231818),
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return SingleChildScrollView(
          child: Container(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Center(
                  child: Container(
                    width: 60,
                    height: 4,
                    decoration: BoxDecoration(
                      color: Colors.grey,
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                ),
                const SizedBox(height: 20),
                Center(
                  child: CircleAvatar(
                    radius: 50,
                    backgroundImage: _partner.photos.isNotEmpty
                        ? NetworkImage(_partner.photos.first)
                        : const AssetImage('assets/default_avatar.png') as ImageProvider,
                  ),
                ),
                const SizedBox(height: 16),
                Center(
                  child: Text(
                    _partner.name,
                    style: const TextStyle(
                      color: Color(0xFFFFD700),
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                Center(
                  child: Text(
                    '${_partner.age} years old • ${_partner.location}',
                    style: const TextStyle(color: Colors.white70, fontSize: 16),
                  ),
                ),
                const SizedBox(height: 20),
                const Text(
                  'About',
                  style: TextStyle(
                    color: Color(0xFFFFD700),
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  _partner.bio.isNotEmpty ? _partner.bio : 'No bio provided',
                  style: const TextStyle(color: Colors.white, fontSize: 16),
                ),
                const SizedBox(height: 20),
                const Text(
                  'Details',
                  style: TextStyle(
                    color: Color(0xFFFFD700),
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                _buildProfileDetail('Profession', _partner.profession),
                _buildProfileDetail('Education', _partner.education),
                _buildProfileDetail('Religion', _partner.religion),
                _buildProfileDetail('Relationship Goals', _partner.relationshipGoals),
                _buildProfileDetail('Exercise Habits', _partner.exerciseHabits),
                const SizedBox(height: 20),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildProfileDetail(String label, String value) {
    if (value.isEmpty) return const SizedBox();
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Text(
            '$label: ',
            style: const TextStyle(color: Colors.white70, fontWeight: FontWeight.bold),
          ),
          Text(
            value,
            style: const TextStyle(color: Colors.white),
          ),
        ],
      ),
    );
  }

  void _startVideoCall() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF231818),
        title: const Text('Video Call', style: TextStyle(color: Color(0xFFFFD700))),
        content: Text('Start video call with ${_partner.name}?', style: const TextStyle(color: Colors.white)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(
              AppLocalizations.of(context, 'cancel'),
              style: const TextStyle(color: Colors.grey),
            ),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              // Implement video call
            },
            style: ElevatedButton.styleFrom(backgroundColor: const Color(0xFFFFD700)),
            child: const Text('Call', style: TextStyle(color: Colors.black)),
          ),
        ],
      ),
    );
  }

  void _startVoiceCall() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF231818),
        title: const Text('Voice Call', style: TextStyle(color: Color(0xFFFFD700))),
        content: Text('Start voice call with ${_partner.name}?', style: const TextStyle(color: Colors.white)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(
              AppLocalizations.of(context, 'cancel'),
              style: const TextStyle(color: Colors.grey),
            ),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              // Implement voice call
            },
            style: ElevatedButton.styleFrom(backgroundColor: const Color(0xFFFFD700)),
            child: const Text('Call', style: TextStyle(color: Colors.black)),
          ),
        ],
      ),
    );
  }

  void _showBlockDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF231818),
        title: const Text('Block User', style: TextStyle(color: Color(0xFFFFD700))),
        content: Text('Are you sure you want to block ${_partner.name}?', style: const TextStyle(color: Colors.white)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(
              AppLocalizations.of(context, 'cancel'),
              style: const TextStyle(color: Colors.grey),
            ),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              _blockUser();
            },
            child: const Text(
              'Block',
              style: TextStyle(color: Colors.red),
            ),
          ),
        ],
      ),
    );
  }

  void _blockUser() {
    final currentUserId = Supabase.instance.client.auth.currentUser?.id;
    if (currentUserId != null) {
      Provider.of<MatchProvider>(context, listen: false).blockUser(currentUserId, _partner.id);
      Navigator.pop(context);
    }
  }

  @override
  void dispose() {
    _messageController.dispose();
    _scrollController.dispose();
    _chatProvider.disposeSubscription();
    super.dispose();
  }
}
